<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Glyphkicker</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; background: #000; overflow: hidden;
             font-family: system-ui, -apple-system, sans-serif; }

#panel {
  position: fixed; left: 0; top: 0; width: 240px; height: 100%;
  overflow-y: auto; background: #111; color: #ccc;
  font-size: 12px; padding: 10px; z-index: 10;
  border-right: 1px solid #222;
}
#panel h1 {
  font-size: 11px; color: #eee; margin-bottom: 14px;
  font-weight: 600; letter-spacing: 0.12em; text-transform: uppercase;
}

.param-row { margin: 8px 0; }
.param-header { display: flex; justify-content: space-between; align-items: baseline;
                margin-bottom: 3px; }
.param-name { font-size: 11px; color: #888; }
.param-val  { font-size: 10px; color: #7af; font-family: monospace; }

input[type=range] {
  width: 100%; cursor: pointer; accent-color: #7af;
  -webkit-appearance: none; appearance: none; background: transparent;
}
input[type=range]::-webkit-slider-runnable-track {
  height: 3px; background: #2a2a2a; border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 11px; height: 11px; border-radius: 50%;
  background: #7af; margin-top: -4px;
}

.color-row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
.color-row label { font-size: 11px; color: #888; flex: 1; }
input[type=color] {
  width: 36px; height: 22px; border: 1px solid #333; background: none;
  cursor: pointer; padding: 1px; border-radius: 3px;
}

.section-label {
  font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
  color: #444; margin: 14px 0 6px; border-top: 1px solid #1e1e1e; padding-top: 8px;
}

select {
  width: 100%; background: #181818; color: #eee;
  border: 1px solid #2a2a2a; padding: 4px 6px; box-sizing: border-box;
  font-size: 11px; margin-top: 4px; cursor: pointer;
  -webkit-appearance: none; appearance: none;
}
select:focus { outline: none; border-color: #336; }

#canvas {
  position: fixed; left: 240px; top: 0;
  width: calc(100% - 240px); height: 100%;
  display: block; outline: none; cursor: text;
}

.btn-group { display: flex; gap: 2px; margin-top: 4px; }
.jbtn {
  flex: 1; padding: 4px 0; font-size: 11px; cursor: pointer; letter-spacing: 0.05em;
  background: #1a1a1a; color: #555; border: 1px solid #2a2a2a; border-radius: 2px;
}
.jbtn.active { background: #1a2a44; color: #7af; border-color: #336; }

.mbtn {
  flex: 1; padding: 4px 0; font-size: 11px; cursor: pointer; letter-spacing: 0.05em;
  background: #1a1a1a; color: #555; border: 1px solid #2a2a2a; border-radius: 2px;
}
.mbtn.active { background: #1a2a44; color: #7af; border-color: #336; }

.bph-empty { font-size: 10px; color: #444; padding: 6px 0; line-height: 1.5; }
.bph-sel-label { font-size: 10px; color: #666; margin-bottom: 6px; }
.bph-behaviour { margin-bottom: 10px; }
.bph-beh-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
.bph-beh-label { font-size: 11px; color: #aaa; }
.bph-beh-remove { background: none; border: none; color: #444; cursor: pointer; font-size: 10px; padding: 0 2px; }
.bph-beh-remove:hover { color: #f77; }

.geo-section-label {
  font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
  color: #333; margin: 8px 0 4px; border-top: 1px solid #191919; padding-top: 6px;
}
#smTriggerInput {
  flex: 1; background: #181818; color: #eee;
  border: 1px solid #2a2a2a; padding: 3px 5px;
  font-size: 11px; outline: none;
}
#smTriggerInput:focus { border-color: #336; }
</style>
</head>
<body>

<div id="panel">
  <h1>Glyphkicker</h1>

  <div class="section-label">Type</div>

  <div class="param-row">
    <div class="param-header"><span class="param-name">Font</span></div>
    <select id="sFontFamily">
      <option value="Gill Sans">Gill Sans</option>
      <option value="Georgia">Georgia</option>
      <option value="Helvetica Neue">Helvetica Neue</option>
      <option value="Palatino">Palatino</option>
      <option value="Times New Roman">Times New Roman</option>
      <option value="Courier New">Courier New</option>
    </select>
  </div>

  <div class="param-row">
    <div class="param-header">
      <span class="param-name">Size</span>
      <span class="param-val" id="vFontPt">48 pt</span>
    </div>
    <input type="range" id="sFontPt" min="12" max="200" step="1" value="48">
  </div>

  <div class="param-row">
    <div class="param-header"><span class="param-name">Justify</span></div>
    <div class="btn-group" id="justifyGroup">
      <button class="jbtn active" data-val="left">Left</button>
      <button class="jbtn"        data-val="center">Center</button>
      <button class="jbtn"        data-val="right">Right</button>
    </div>
  </div>

  <div class="section-label">Colour</div>

  <div class="color-row">
    <label>Text</label>
    <input type="color" id="cText" value="#ffffff">
  </div>
  <div class="color-row">
    <label>Background</label>
    <input type="color" id="cBg" value="#000000">
  </div>

  <div class="section-label">Mode</div>
  <div class="btn-group" id="modeGroup">
    <button class="mbtn active" data-mode="type">Type</button>
    <button class="mbtn"        data-mode="select">Select</button>
  </div>

  <div class="section-label">Agent</div>
  <button id="contagionBtn" class="jbtn" style="width:100%;margin-top:2px">Attach Contagion</button>
  <button id="predPreyBtn"  class="jbtn" style="width:100%;margin-top:4px">Attach Pred/Prey</button>
  <div style="font-size:9px;color:#444;margin-top:3px">selected = predators, rest = prey</div>

  <div id="predPreyParams" style="display:none;margin-top:6px">
    <div class="param-row">
      <div class="param-header">
        <span class="param-name">Hunt radius</span>
        <span class="param-val" id="vHuntRadius">200 px</span>
      </div>
      <input type="range" id="sHuntRadius" min="50" max="500" step="10" value="200">
    </div>
    <div class="param-row">
      <div class="param-header">
        <span class="param-name">Attract speed</span>
        <span class="param-val" id="vAttractStrength">280</span>
      </div>
      <input type="range" id="sAttractStrength" min="50" max="800" step="10" value="280">
    </div>
    <div class="param-row">
      <div class="param-header">
        <span class="param-name">Flee speed</span>
        <span class="param-val" id="vFleeStrength">400</span>
      </div>
      <input type="range" id="sFleeStrength" min="50" max="800" step="10" value="400">
    </div>
    <div class="param-row">
      <div class="param-header">
        <span class="param-name">Calm time</span>
        <span class="param-val" id="vCalmTime">1.5 s</span>
      </div>
      <input type="range" id="sCalmTime" min="0.5" max="8" step="0.5" value="1.5">
    </div>
  </div>

  <div id="selectionPanel" style="display:none">
    <div class="section-label">Behaviours</div>
    <div id="bPanel"></div>
    <div class="param-row">
      <select id="bAdd">
        <option value="">— add behaviour —</option>
        <option value="Drift">Drift</option>
        <option value="Wander">Wander</option>
        <option value="Shake">Shake</option>
        <option value="Flicker">Flicker</option>
        <option value="Pulse">Pulse</option>
        <option value="Gravity">Gravity</option>
        <option value="Attract">Attract</option>
        <option value="Repel">Repel</option>
        <option value="SpringHome">Spring Home</option>
        <option value="Orbit">Orbit</option>
        <option value="ParticleFlocking">Particle Flocking</option>
        <option value="ParticleOutside">Particle Outside</option>
      </select>
    </div>
    <div class="section-label">Geometry</div>
    <div id="geoPanel"></div>

    <div class="section-label">Agent</div>
    <div id="agentPanel">
      <div style="display:flex;gap:4px;margin-top:2px">
        <input type="text" id="smTriggerInput" placeholder="message type">
        <button id="smSendBtn" class="jbtn" style="flex:0 0 42px">Send</button>
      </div>
      <div style="font-size:9px;color:#444;margin-top:3px">sends to selected glyphs</div>
    </div>
  </div>
</div>

<canvas id="canvas" tabindex="0"></canvas>

<script>
'use strict';

// ── Constants ──────────────────────────────────────────────────────────────────
const PANEL_W     = 240;
const MARGIN      = 40;
const LINE_H_MULT = 1.45;
const FIXED_DT    = 1 / 60;   // fixed physics timestep (seconds)

// ── Params ─────────────────────────────────────────────────────────────────────
const PARAMS = {
  fontFamily: 'Gill Sans',
  fontPt:     48,
  color:      '#ffffff',
  background: '#000000',
  justify:    'left',
};

// ── Seeded RNG ─────────────────────────────────────────────────────────────────
// Deterministic per-glyph random — same seed always produces the same sequence.
function hashStr(s) {
  let h = 0x811c9dc5;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h  = Math.imul(h, 0x01000193) >>> 0;
  }
  return h || 1;
}

function makeRNG(seed) {
  let s = typeof seed === 'string' ? hashStr(seed) : ((seed >>> 0) || 1);
  return () => {
    s = (Math.imul(1664525, s) + 1013904223) >>> 0;
    return s / 0x100000000;
  };
}

// ── Canvas ─────────────────────────────────────────────────────────────────────
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
const dpr    = window.devicePixelRatio || 1;
let W = 0, H = 0;

// ── Input state ─────────────────────────────────────────────────────────────────
const inputState = { x: 0, y: 0, down: false, onCanvas: false };

function resizeCanvas() {
  W = window.innerWidth - PANEL_W;
  H = window.innerHeight;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  layout();
}
window.addEventListener('resize', resizeCanvas);

// ── Document model ─────────────────────────────────────────────────────────────
let docText        = '';
let cursorPos      = 0;
let anchorPos      = 0;     // text-range selection anchor; equals cursorPos when no range active
let glyphs         = [];
let prevDocText    = '';    // last-laid-out string, used for position transfer

// Layout origin — where the first line baseline starts. Updated by blank-canvas clicks.
let layoutOriginX  = MARGIN;
let layoutOriginY  = null;  // null → MARGIN + fontPt (computed at layout time)

// ── Editor mode & selection ─────────────────────────────────────────────────────
let editorMode    = 'type';    // 'type' | 'select'
let selectedIds   = new Set(); // IDs of currently selected glyph agents
let selectedGlyphs = [];       // live references (re-synced after each layout)

// ── Undo / Redo ─────────────────────────────────────────────────────────────────
const undoStack = [];
const redoStack = [];
const MAX_UNDO  = 100;

function captureSnapshot() {
  return {
    docText,
    cursorPos,
    anchorPos,
    glyphByIndex: new Map(glyphs.map(g => [g.index, {
      x:            g.x,
      y:            g.y,
      rotation:     g.rotation,
      scale:        g.scale,
      dynamics:     { ...g.dynamics },
      material:     { ...g.material },
      geometryType: g.geometry.type,
      behaviours:   g.behaviours.map(b => {
        const def = BEHAVIOUR_DEFS.find(d => d.type === b.type);
        return def ? { key: def.key, params: { ...b.params } } : null;
      }).filter(Boolean),
    }])),
  };
}

function pushUndo() {
  undoStack.push(captureSnapshot());
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0;
}

function applySnapshot(snap) {
  docText     = snap.docText;
  cursorPos   = snap.cursorPos;
  anchorPos   = snap.anchorPos;
  prevDocText = '';
  glyphs      = [];
  layout();
  for (const g of glyphs) {
    const s = snap.glyphByIndex.get(g.index);
    if (!s) continue;
    g.x          = s.x;
    g.y          = s.y;
    g.rotation   = s.rotation;
    g.scale      = s.scale;
    g.dynamics   = { ...s.dynamics };
    g.material   = { ...s.material };
    g.geometry   = { type: s.geometryType };
    g.behaviours = s.behaviours.map(b => {
      const def = BEHAVIOUR_DEFS.find(d => d.key === b.key);
      return def ? { type: def.type, params: { ...b.params } } : null;
    }).filter(Boolean);
  }
  selectedIds    = new Set();
  selectedGlyphs = [];
  if (editorMode === 'select') { updateBehaviourPanel(); updateGeometryPanel(); }
  resetBlink();
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push(captureSnapshot());
  applySnapshot(undoStack.pop());
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push(captureSnapshot());
  applySnapshot(redoStack.pop());
}

// ── GlyphAgent ─────────────────────────────────────────────────────────────────
let _uid = 0;

function makeGlyph(char, index, hx, hy, w) {
  const id = `g${_uid++}`;
  return {
    id,
    char,
    index,
    homeX: hx, homeY: hy,   // typographic home (CSS px) — set by layout
    x: hx, y: hy,            // current visual position
    rotation: 0,             // radians
    scale: 1,                // uniform scale (1 = normal)

    w,                       // advance width (CSS px)

    // ── ECS components ──────────────────────────────────────────────────────
    dynamics: {
      vx: 0, vy: 0,          // CSS px/s
      angularVel: 0,         // rad/s
      damping: 0.92,         // velocity multiplier each physics step
    },
    material: {
      fill:      null,       // null → inherit PARAMS.color
      opacity:   1,
      blendMode: 'source-over',
    },
    geometry:    { type: 'outline2d' },
    interaction: { hovered: false, selected: false },

    // Active behaviour instances — each is { type: <Behaviour>, params: {...} }
    behaviours: [],

    // Behaviour state — keyed by Symbol, owned by individual behaviours
    _state: new Map(),

    // Agent mailbox — messages queue here and are drained each frame by AgentEngine
    mailbox: [],

    // Optional state machine (set by makeStateMachine)
    stateMachine: null,

    // Deterministic RNG seeded from this glyph's id
    rng: makeRNG(id),
  };
}

// ── Position transfer helpers ──────────────────────────────────────────────────
// Copy all visual/dynamic state from a previous glyph agent to a newly-built one.
// Raw: dst keeps src's exact visual position (for same-character identity).
function transferGlyph(src, dst) {
  dst.id           = src.id;
  dst.x            = src.x;
  dst.y            = src.y;
  dst.rotation     = src.rotation;
  dst.scale        = src.scale;
  dst.dynamics     = src.dynamics;
  dst.material     = src.material;
  dst.geometry     = src.geometry;   // preserve particle state across layout reflows
  dst._state       = src._state;
  dst.rng          = src.rng;
  dst.behaviours   = src.behaviours;
  dst.stateMachine = src.stateMachine;
  dst.mailbox      = [];
}
// Relative: dst snaps to its new home while preserving any drift offset from src.
// Use this when the glyph's home position has shifted (insertion/deletion of neighbours).
function transferGlyphRelative(src, dst) {
  dst.id           = src.id;
  dst.x            = dst.homeX + (src.x - src.homeX);
  dst.y            = dst.homeY + (src.y - src.homeY);
  dst.rotation     = src.rotation;
  dst.scale        = src.scale;
  dst.dynamics     = src.dynamics;
  dst.material     = src.material;
  dst.geometry     = src.geometry;
  dst._state       = src._state;
  dst.rng          = src.rng;
  dst.behaviours   = src.behaviours;
  dst.stateMachine = src.stateMachine;
  dst.mailbox      = [];
}

// Set initial position of a brand-new glyph by interpolating between its
// nearest visible neighbours — but only if they have actually drifted from home.
// When no behaviours are active the neighbours sit at home, so we just use
// this glyph's own homeX/homeY (already set by makeGlyph).
function spawnInterpolated(g, arr) {
  const idx = arr.indexOf(g);
  let L = null, R = null;
  for (let i = idx - 1; i >= 0; i--) {
    if (arr[i].char !== '\n' && arr[i].char !== ' ') { L = arr[i]; break; }
  }
  for (let i = idx + 1; i < arr.length; i++) {
    if (arr[i].char !== '\n' && arr[i].char !== ' ') { R = arr[i]; break; }
  }
  const drifted = n => n && (Math.abs(n.x - n.homeX) > 5 || Math.abs(n.y - n.homeY) > 5);
  const ld = drifted(L), rd = drifted(R);
  if      (ld && rd) { g.x = (L.x + R.x) * 0.5; g.y = (L.y + R.y) * 0.5; }
  else if (ld)       { g.x = L.x; g.y = L.y; }
  else if (rd)       { g.x = R.x; g.y = R.y; }
  // else: neighbours are at home — keep this glyph's own homeX/homeY
}

// ── Layout engine ──────────────────────────────────────────────────────────────
function fontStr() {
  return `${PARAMS.fontPt}px "${PARAMS.fontFamily}", serif`;
}

// Returns the x-start for a line whose visible content is contentW pixels wide.
function justifyX(contentW) {
  switch (PARAMS.justify) {
    case 'center': return Math.max(MARGIN, (W - contentW) / 2);
    case 'right':  return Math.max(MARGIN, W - MARGIN - contentW);
    default:       return layoutOriginX;
  }
}

function layout() {
  if (!W) return;

  ctx.font         = fontStr();
  ctx.textBaseline = 'alphabetic';

  const lineH  = PARAMS.fontPt * LINE_H_MULT;
  const spaceW = ctx.measureText(' ').width;
  const next   = [];

  // ── Parse text into segments ──────────────────────────────────────────────
  const segs = [];
  let word = '', wordStart = 0;
  for (let i = 0; i <= docText.length; i++) {
    const ch = i < docText.length ? docText[i] : null;
    if (ch === null || ch === ' ' || ch === '\n') {
      if (word.length) { segs.push({ type: 'word', text: word, start: wordStart }); word = ''; }
      if (ch === ' ')  segs.push({ type: 'space',  text: ' ',  start: i });
      if (ch === '\n') segs.push({ type: 'newline', text: '\n', start: i });
    } else {
      if (!word.length) wordStart = i;
      word += ch;
    }
  }

  // ── First pass: break segments into visual lines ──────────────────────────
  // Each line: { items: [{seg, cws?}], contentW (trailing spaces excluded) }
  const lines = [];
  let curItems = [], runX = 0, runW = 0;

  const flushLine = () => {
    let trimW = runW;
    for (let i = curItems.length - 1; i >= 0; i--) {
      if (curItems[i].seg.type === 'space') trimW -= spaceW; else break;
    }
    lines.push({ items: curItems, contentW: trimW });
    curItems = []; runX = 0; runW = 0;
  };

  for (const seg of segs) {
    if (seg.type === 'newline') {
      curItems.push({ seg }); flushLine();
    } else if (seg.type === 'space') {
      curItems.push({ seg }); runX += spaceW; runW += spaceW;
    } else {
      const cws   = [...seg.text].map(c => ctx.measureText(c).width);
      const wordW = cws.reduce((a, b) => a + b, 0);
      if (runX > 0 && runX + wordW > W - 2 * MARGIN) flushLine();
      curItems.push({ seg, cws, wordW }); runX += wordW; runW += wordW;
    }
  }
  if (curItems.length) flushLine();

  // ── Second pass: place glyphs anchored by justification ──────────────────
  let y = layoutOriginY !== null ? layoutOriginY : MARGIN + PARAMS.fontPt;
  for (const line of lines) {
    let x = justifyX(line.contentW);
    let endedWithNewline = false;
    for (const { seg, cws } of line.items) {
      if (seg.type === 'newline') {
        next.push(makeGlyph('\n', seg.start, x, y, 0)); y += lineH;
        endedWithNewline = true;
      } else if (seg.type === 'space') {
        next.push(makeGlyph(' ', seg.start, x, y, spaceW)); x += spaceW;
        endedWithNewline = false;
      } else {
        for (let k = 0; k < seg.text.length; k++) {
          next.push(makeGlyph(seg.text[k], seg.start + k, x, y, cws[k]));
          x += cws[k];
        }
        endedWithNewline = false;
      }
    }
    // Word-wrapped lines have no newline token — advance y here.
    if (!endedWithNewline) y += lineH;
  }

  // ── Transfer visual state from previous glyphs ────────────────────────────
  // Detect what kind of edit happened so we can match character identity.
  const prevByIdx = new Map(glyphs.map(g => [g.index, g]));
  const newLen    = docText.length;
  const oldLen    = prevDocText.length;

  if (newLen === oldLen + 1) {
    // Single insertion: find where the new character was inserted
    let p = 0;
    while (p < oldLen && prevDocText[p] === docText[p]) p++;
    for (const g of next) {
      if (g.index < p)  { const s = prevByIdx.get(g.index);     if (s) transferGlyph(s, g); }
      else if (g.index === p) { spawnInterpolated(g, next); }
      else              { const s = prevByIdx.get(g.index - 1); if (s) transferGlyphRelative(s, g); }
    }
  } else if (newLen < oldLen) {
    // Any deletion (single char, word-delete, or range delete)
    let p = 0;
    while (p < newLen && docText[p] === prevDocText[p]) p++;
    const dc = oldLen - newLen;
    for (const g of next) {
      const s = g.index < p
        ? prevByIdx.get(g.index)
        : prevByIdx.get(g.index + dc);
      if (s) transferGlyphRelative(s, g);
    }
  } else if (newLen > oldLen) {
    // Paste or multi-insert: transfer what matches, interpolate the rest
    for (const g of next) {
      const s = prevByIdx.get(g.index);
      if (s && s.char === g.char) transferGlyph(s, g);
    }
    for (const g of next) {
      if (!prevByIdx.has(g.index)) spawnInterpolated(g, next);
    }
  } else {
    // Font change, resize, or other same-length edit: reflow home positions
    // but preserve each glyph's drift offset relative to its new home.
    for (const g of next) {
      const s = prevByIdx.get(g.index);
      if (!s) continue;
      transferGlyphRelative(s, g);
    }
  }

  prevDocText = docText;
  glyphs = next;
  AgentEngine.pruneTimers();
  // Re-sync selected glyph references — layout rebuilds the array but transferGlyph preserves ids.
  selectedGlyphs = glyphs.filter(g => selectedIds.has(g.id));
  if (editorMode === 'select') {
    updateBehaviourPanel();
    updateGeometryPanel();
  }
}

// ── Behaviour system ────────────────────────────────────────────────────────────
// Stateless singletons: { sym, defaults, apply(g, dt, ctx, params) }
// Per-glyph state lives in g._state.get(Behaviour.sym)

const Drift = {
  sym:      Symbol('Drift'),
  defaults: { amplitude: 60, speed: 25 },
  apply(g, dt, ctx, p) {
    let s = g._state.get(Drift.sym);
    if (!s) {
      // Target stored as offset from home so it tracks home across layout reflows.
      s = { dx: 0, dy: 0 };
      g._state.set(Drift.sym, s);
    }
    const tx = g.homeX + s.dx, ty = g.homeY + s.dy;
    const vx = tx - g.x,       vy = ty - g.y;
    const d  = Math.hypot(vx, vy);
    if (d < 4) {
      // Arrived — pick new wander target as offset from home
      const angle = g.rng() * Math.PI * 2;
      const r     = g.rng() * p.amplitude;
      s.dx = Math.cos(angle) * r;
      s.dy = Math.sin(angle) * r;
    } else {
      // Blend velocity toward desired speed in direction of target
      g.dynamics.vx += ((vx / d) * p.speed - g.dynamics.vx) * 0.12;
      g.dynamics.vy += ((vy / d) * p.speed - g.dynamics.vy) * 0.12;
    }
  },
};

const Shake = {
  sym:      Symbol('Shake'),
  defaults: { amplitude: 4, speed: 15 },
  apply(g, dt, ctx, p) {
    let s = g._state.get(Shake.sym);
    if (!s) {
      s = { px: g.rng() * Math.PI * 2, py: g.rng() * Math.PI * 2 };
      g._state.set(Shake.sym, s);
    }
    const w = p.speed * Math.PI * 2;
    const t = ctx.time;
    g.dynamics.vx += Math.cos(t * w + s.px) * p.amplitude * w * dt;
    g.dynamics.vy += Math.cos(t * w + s.py) * p.amplitude * w * dt * 0.7;
  },
};

// Geometry-specific behaviours: no-op if the glyph does not have particle geometry.

// Reynolds boids flocking (separation, alignment, cohesion) applied to the
// particle cloud of a particle-geometry glyph.
// Runs its O(n²) loop before stepParticleGeometry integrates position.
// solidifyT (from cellPx) scales forces down so particles settle at small sizes.
const ParticleFlocking = {
  sym:      Symbol('ParticleFlocking'),
  defaults: { perception: 88, separation: 4.4, alignment: 0.3, cohesion: 0 },
  apply(g, dt, bCtx, p) {
    if (g.geometry.type !== 'particles' || !g.geometry.data) return;

    const gd  = g.geometry.data;
    const pp  = g.geometry.params;
    const ps  = gd.particles;
    const n   = ps.length;
    const vmax      = pp.particleSpeed * 1.5;
    const perc      = p.perception;
    const perc2     = perc * perc;
    const sepR2     = (perc * 0.5) * (perc * 0.5);
    const solidifyT = Math.min(1, Math.max(0, 3 - pp.cellPx));
    const fScale    = 1 - solidifyT;
    const out       = pp.outside / 100;
    const { mask, maskW, maskH } = gd;

    const inside = (lx, ly) => {
      const xi = Math.round(lx + maskW / 2);
      const yi = Math.round(ly + maskH / 2);
      if (xi < 0 || xi >= maskW || yi < 0 || yi >= maskH) return false;
      return mask[yi * maskW + xi] === 1;
    };

    for (let i = 0; i < n; i++) {
      const pi = ps[i];
      // Suppress flocking for escaped particles when fully contained.
      if (out === 0 && !inside(pi.x, pi.y)) continue;

      let sx = 0, sy = 0, ax = 0, ay = 0, cx = 0, cy = 0, nc = 0;

      for (let j = 0; j < n; j++) {
        if (j === i) continue;
        const pj  = ps[j];
        const ddx = pj.x - pi.x, ddy = pj.y - pi.y;
        const d2  = ddx * ddx + ddy * ddy;
        if (d2 > perc2) continue;
        if (d2 < sepR2 && d2 > 0) { sx -= ddx / d2; sy -= ddy / d2; }
        ax += pj.vx; ay += pj.vy;
        cx += pj.x;  cy += pj.y;
        nc++;
      }

      if (nc === 0) continue;

      let fx = 0, fy = 0;
      const sm = Math.hypot(sx, sy);
      if (sm > 0) {
        fx += (sx / sm * vmax - pi.vx) * p.separation;
        fy += (sy / sm * vmax - pi.vy) * p.separation;
      }
      const am = Math.hypot(ax, ay) || 1;
      fx += (ax / am * vmax - pi.vx) * p.alignment;
      fy += (ay / am * vmax - pi.vy) * p.alignment;
      const tcx = cx / nc - pi.x, tcy = cy / nc - pi.y;
      const tm  = Math.hypot(tcx, tcy) || 1;
      fx += (tcx / tm * vmax - pi.vx) * p.cohesion;
      fy += (tcy / tm * vmax - pi.vy) * p.cohesion;

      // Scale forces down as particles crystallise (small cellPx).
      pi.vx += fx * fScale * dt;
      pi.vy += fy * fScale * dt;
    }
  },
};

// Allows particles to drift across the glyph boundary and wander back.
// Writes pp.outside each frame so stepParticleGeometry reads the correct value.
// Note: if this behaviour is removed, pp.outside retains the last value until
// the geometry panel Outside slider is moved (v1 limitation).
const ParticleOutside = {
  sym:      Symbol('ParticleOutside'),
  defaults: { outside: 50 },
  apply(g, dt, bCtx, p) {
    if (g.geometry.type !== 'particles') return;
    g.geometry.params.outside = p.outside;
  },
};

// ── General behaviours ────────────────────────────────────────────────────────

// Oscillates opacity between min and max at the given rate (Hz).
const Flicker = {
  sym:      Symbol('Flicker'),
  defaults: { rate: 2, min: 0.2 },
  apply(g, dt, bCtx, p) {
    let s = g._state.get(Flicker.sym);
    if (!s) { s = { phase: g.rng() * Math.PI * 2 }; g._state.set(Flicker.sym, s); }
    s.phase += p.rate * Math.PI * 2 * dt;
    const t = (Math.sin(s.phase) + 1) * 0.5;
    g.material.opacity = p.min + t * (1 - p.min);
  },
};

// Oscillates scale around 1 at the given speed (Hz).
const Pulse = {
  sym:      Symbol('Pulse'),
  defaults: { amplitude: 0.3, speed: 1 },
  apply(g, dt, bCtx, p) {
    let s = g._state.get(Pulse.sym);
    if (!s) { s = { phase: g.rng() * Math.PI * 2 }; g._state.set(Pulse.sym, s); }
    s.phase += p.speed * Math.PI * 2 * dt;
    g.scale = 1 + p.amplitude * Math.sin(s.phase);
  },
};

// Elastic spring pulling each glyph toward its home position.
const SpringHome = {
  sym:      Symbol('SpringHome'),
  defaults: { stiffness: 12 },
  apply(g, dt, bCtx, p) {
    g.dynamics.vx += (g.homeX - g.x) * p.stiffness * dt;
    g.dynamics.vy += (g.homeY - g.y) * p.stiffness * dt;
  },
};

// Random walk across the canvas (target not anchored to home).
const Wander = {
  sym:      Symbol('Wander'),
  defaults: { radius: 160, speed: 45 },
  apply(g, dt, bCtx, p) {
    let s = g._state.get(Wander.sym);
    if (!s) {
      s = { tx: g.x, ty: g.y };
      g._state.set(Wander.sym, s);
    }
    const dx = s.tx - g.x, dy = s.ty - g.y;
    const d  = Math.hypot(dx, dy);
    if (d < 6) {
      const angle = g.rng() * Math.PI * 2;
      const r     = g.rng() * p.radius;
      s.tx = Math.max(0, Math.min(W, g.x + Math.cos(angle) * r));
      s.ty = Math.max(0, Math.min(H, g.y + Math.sin(angle) * r));
    } else {
      g.dynamics.vx += ((dx / d) * p.speed - g.dynamics.vx) * 0.12;
      g.dynamics.vy += ((dy / d) * p.speed - g.dynamics.vy) * 0.12;
    }
  },
};

// Simulated gravity with floor bounce. Floor is % of canvas height.
const Gravity = {
  sym:      Symbol('Gravity'),
  defaults: { gravity: 400, bounce: 0.55, floor: 90 },
  apply(g, dt, bCtx, p) {
    g.dynamics.vy += p.gravity * dt;
    const floor = p.floor / 100 * H;
    if (g.y > floor) {
      g.y = floor;
      g.dynamics.vy *= -p.bounce;
      g.dynamics.vx *= 0.88; // friction
    }
  },
};

// Pulls the glyph toward the pointer with inverse-distance force.
const Attract = {
  sym:      Symbol('Attract'),
  defaults: { strength: 200, radius: 300 },
  apply(g, dt, bCtx, p) {
    if (!bCtx.inputState.onCanvas) return;
    const cx = g.x + g.w * 0.5, cy = g.y - PARAMS.fontPt * 0.4;
    const dx = bCtx.inputState.x - cx, dy = bCtx.inputState.y - cy;
    const d  = Math.hypot(dx, dy);
    if (d < 1 || d > p.radius) return;
    const f = p.strength / (d + 1);
    g.dynamics.vx += (dx / d) * f * dt;
    g.dynamics.vy += (dy / d) * f * dt;
  },
};

// Pushes the glyph away from the pointer.
const Repel = {
  sym:      Symbol('Repel'),
  defaults: { strength: 400, radius: 120 },
  apply(g, dt, bCtx, p) {
    if (!bCtx.inputState.onCanvas) return;
    const cx = g.x + g.w * 0.5, cy = g.y - PARAMS.fontPt * 0.4;
    const dx = cx - bCtx.inputState.x, dy = cy - bCtx.inputState.y;
    const d  = Math.hypot(dx, dy);
    if (d < 1 || d > p.radius) return;
    const f = p.strength * (1 - d / p.radius) / (d + 1);
    g.dynamics.vx += (dx / d) * f * dt;
    g.dynamics.vy += (dy / d) * f * dt;
  },
};

// Pushes the glyph away from a stored world point (set by a state machine).
// The flee target is read from g._state.get(Flee.sym) = { tx, ty }.
// No-op if no target has been stored yet.
const Flee = {
  sym:      Symbol('Flee'),
  defaults: { strength: 350, radius: 220 },
  apply(g, dt, bCtx, p) {
    const s = g._state.get(Flee.sym);
    if (!s) return;
    const cx = g.x + g.w * 0.5, cy = g.y - PARAMS.fontPt * 0.4;
    const dx = cx - s.tx, dy = cy - s.ty;
    const d  = Math.hypot(dx, dy);
    if (d < 1 || d > p.radius) return;
    // Constant-speed steering away from predator (mirrors ChasePointer)
    g.dynamics.vx += ((dx / d) * p.strength - g.dynamics.vx) * 0.12;
    g.dynamics.vy += ((dy / d) * p.strength - g.dynamics.vy) * 0.12;
  },
};

/// SM-internal: steers toward mouse pointer at constant speed regardless of distance.
// Used by predatorStates — not exposed in BEHAVIOUR_DEFS dropdown.
const ChasePointer = {
  sym:      Symbol('ChasePointer'),
  defaults: { speed: 280 },
  apply(g, dt, bCtx, p) {
    if (!bCtx.inputState.onCanvas) return;
    const cx = g.x + g.w * 0.5, cy = g.y - PARAMS.fontPt * 0.4;
    const dx = bCtx.inputState.x - cx, dy = bCtx.inputState.y - cy;
    const d  = Math.hypot(dx, dy);
    if (d < 1) return;
    // Blend velocity toward desired direction at constant speed (same pattern as Drift)
    g.dynamics.vx += ((dx / d) * p.speed - g.dynamics.vx) * 0.12;
    g.dynamics.vy += ((dy / d) * p.speed - g.dynamics.vy) * 0.12;
  },
};

// Circular orbit around the glyph's home position.
const Orbit = {
  sym:      Symbol('Orbit'),
  defaults: { radius: 40, speed: 90 },  // speed in °/s
  apply(g, dt, bCtx, p) {
    let s = g._state.get(Orbit.sym);
    if (!s) {
      s = { angle: Math.atan2(g.y - g.homeY, g.x - g.homeX) };
      g._state.set(Orbit.sym, s);
    }
    s.angle += p.speed * Math.PI / 180 * dt;
    const tx = g.homeX + Math.cos(s.angle) * p.radius;
    const ty = g.homeY + Math.sin(s.angle) * p.radius;
    g.dynamics.vx += (tx - g.x) * 20 * dt;
    g.dynamics.vy += (ty - g.y) * 20 * dt;
  },
};

// ── Behaviour registry ──────────────────────────────────────────────────────────
const BEHAVIOUR_DEFS = [
  {
    key: 'Drift', type: Drift, label: 'Drift',
    params: [
      { key: 'amplitude', label: 'Amplitude', min: 5,   max: 200, step: 1,   suffix: 'px',   default: 60 },
      { key: 'speed',     label: 'Speed',     min: 5,   max: 100, step: 1,   suffix: 'px/s', default: 25 },
    ],
  },
  {
    key: 'Shake', type: Shake, label: 'Shake',
    params: [
      { key: 'amplitude', label: 'Amplitude', min: 0.5, max: 20,  step: 0.5, suffix: 'px',   default: 4 },
      { key: 'speed',     label: 'Speed',     min: 1,   max: 30,  step: 0.5, suffix: 'Hz',   default: 15 },
    ],
  },
  {
    key: 'Flicker', type: Flicker, label: 'Flicker',
    params: [
      { key: 'rate', label: 'Rate',    min: 0.2, max: 20,  step: 0.1, suffix: 'Hz', default: 2   },
      { key: 'min',  label: 'Min α',   min: 0,   max: 0.95, step: 0.05, suffix: '',  default: 0.2 },
    ],
  },
  {
    key: 'Pulse', type: Pulse, label: 'Pulse',
    params: [
      { key: 'amplitude', label: 'Amplitude', min: 0.05, max: 1,  step: 0.05, suffix: '×', default: 0.3 },
      { key: 'speed',     label: 'Speed',     min: 0.2,  max: 10, step: 0.1,  suffix: 'Hz', default: 1  },
    ],
  },
  {
    key: 'SpringHome', type: SpringHome, label: 'Spring Home',
    params: [
      { key: 'stiffness', label: 'Stiffness', min: 1, max: 60, step: 1, suffix: '', default: 12 },
    ],
  },
  {
    key: 'Wander', type: Wander, label: 'Wander',
    params: [
      { key: 'radius', label: 'Radius', min: 20,  max: 600, step: 10, suffix: 'px',   default: 160 },
      { key: 'speed',  label: 'Speed',  min: 10,  max: 200, step: 5,  suffix: 'px/s', default: 45  },
    ],
  },
  {
    key: 'Gravity', type: Gravity, label: 'Gravity',
    params: [
      { key: 'gravity', label: 'Gravity', min: 50,  max: 1200, step: 50,  suffix: 'px/s²', default: 400  },
      { key: 'bounce',  label: 'Bounce',  min: 0,   max: 1,    step: 0.05, suffix: '',      default: 0.55 },
      { key: 'floor',   label: 'Floor',   min: 10,  max: 100,  step: 1,   suffix: '%',     default: 90   },
    ],
  },
  {
    key: 'Attract', type: Attract, label: 'Attract',
    params: [
      { key: 'strength', label: 'Strength', min: 20,  max: 1000, step: 20,  suffix: '',   default: 200 },
      { key: 'radius',   label: 'Radius',   min: 20,  max: 600,  step: 10,  suffix: 'px', default: 300 },
    ],
  },
  {
    key: 'Repel', type: Repel, label: 'Repel',
    params: [
      { key: 'strength', label: 'Strength', min: 20,  max: 2000, step: 20,  suffix: '',   default: 400 },
      { key: 'radius',   label: 'Radius',   min: 20,  max: 400,  step: 10,  suffix: 'px', default: 120 },
    ],
  },
  {
    key: 'Orbit', type: Orbit, label: 'Orbit',
    params: [
      { key: 'radius', label: 'Radius', min: 5,  max: 300, step: 5,  suffix: 'px',  default: 40 },
      { key: 'speed',  label: 'Speed',  min: 10, max: 720, step: 10, suffix: '°/s', default: 90 },
    ],
  },
  {
    key: 'ParticleFlocking', type: ParticleFlocking, label: 'Particle Flocking',
    params: [
      { key: 'perception', label: 'Perception', min: 5,   max: 200, step: 1,   suffix: 'px', default: 88  },
      { key: 'separation', label: 'Separation', min: 0,   max: 8,   step: 0.1, suffix: '',   default: 4.4 },
      { key: 'alignment',  label: 'Alignment',  min: 0,   max: 5,   step: 0.1, suffix: '',   default: 0.3 },
      { key: 'cohesion',   label: 'Cohesion',   min: 0,   max: 5,   step: 0.1, suffix: '',   default: 0   },
    ],
  },
  {
    key: 'ParticleOutside', type: ParticleOutside, label: 'Particle Outside',
    params: [
      { key: 'outside', label: 'Outside', min: 0, max: 100, step: 1, suffix: '%', default: 50 },
    ],
  },
];

// ── State Machine ───────────────────────────────────────────────────────────────
// makeStateMachine(statesDef, initialState) → SM object.
// statesDef: { stateName: { behaviours[], onEnter, onExit, onMessage } }
// The SM auto-injects/removes its behaviours on state transitions.
// User-added behaviours (in g.behaviours before SM attach) are never touched.
function makeStateMachine(statesDef, initialState) {
  let _current  = initialState;
  let _injected = [];   // behaviour instances injected by the current state

  function _transition(g, nextState, bCtx) {
    if (nextState === _current) return;
    const exitDef  = statesDef[_current];
    const enterDef = statesDef[nextState];
    if (!enterDef) { console.warn('SM: unknown state', nextState); return; }

    // Exit: call onExit, remove injected behaviours
    if (exitDef && exitDef.onExit) exitDef.onExit(g, bCtx);
    for (const inst of _injected) {
      const idx = g.behaviours.indexOf(inst);
      if (idx !== -1) g.behaviours.splice(idx, 1);
    }
    _injected = [];

    _current = nextState;

    // Enter: inject state behaviours, then call onEnter
    if (enterDef.behaviours) {
      for (const bSpec of enterDef.behaviours) {
        const inst = { type: bSpec.type, params: { ...bSpec.type.defaults, ...bSpec.params } };
        g.behaviours.push(inst);
        _injected.push(inst);
      }
    }
    if (enterDef.onEnter) enterDef.onEnter(g, bCtx);
  }

  return {
    // Called once after attaching SM to a glyph (bCtx may be null during pre-frame init)
    init(g, bCtx) {
      const def = statesDef[_current];
      if (def && def.behaviours) {
        for (const bSpec of def.behaviours) {
          const inst = { type: bSpec.type, params: { ...bSpec.type.defaults, ...bSpec.params } };
          g.behaviours.push(inst);
          _injected.push(inst);
        }
      }
      if (def && def.onEnter) def.onEnter(g, bCtx);
    },
    // Called by AgentEngine phase 3 for each message in g.mailbox
    receive(g, msg, bCtx) {
      const def = statesDef[_current];
      if (!def || !def.onMessage) return;
      const next = def.onMessage(g, msg, bCtx);
      if (next && next !== _current) _transition(g, next, bCtx);
    },
    currentState() { return _current; },
    // Remove injected behaviours and detach SM from glyph
    detach(g) {
      for (const inst of _injected) {
        const idx = g.behaviours.indexOf(inst);
        if (idx !== -1) g.behaviours.splice(idx, 1);
      }
      _injected = [];
      g.stateMachine = null;
    },
  };
}

// ── AgentEngine ─────────────────────────────────────────────────────────────────
// Singleton that runs the 7-phase agent loop, replacing stepDynamics().
// Phases 5-7 are the v1 physics (unchanged); phases 1-4 are the new agent layer.
const AgentEngine = (() => {
  let _outbox  = [];
  const _timers = [];    // { targetId, type, data, fireAt }
  const _SYS_NEAR_SYM = Symbol('_sysNear');
  const NEAR_RADIUS   = 120;   // px for pointer-near system messages

  // Queue a message to one glyph (by reference or id string) — delivers next frame
  function send(target, type, data, fromId) {
    const id = typeof target === 'string' ? target : target.id;
    _outbox.push({ targetId: id, type, data: data || {}, fromId: fromId || null });
  }

  // Queue to all non-space glyphs within radius px of fromGlyph — delivers next frame
  function broadcast(fromGlyph, radius, type, data) {
    const cx = fromGlyph.x + fromGlyph.w * 0.5;
    const cy = fromGlyph.y - PARAMS.fontPt * 0.4;
    for (const g of glyphs) {
      if (g === fromGlyph || g.char === ' ' || g.char === '\n') continue;
      const gx = g.x + g.w * 0.5;
      const gy = g.y - PARAMS.fontPt * 0.4;
      if (Math.hypot(gx - cx, gy - cy) <= radius) {
        _outbox.push({ targetId: g.id, type, data: data || {}, fromId: fromGlyph.id });
      }
    }
  }

  // Queue to all non-space glyphs in the same word as fromGlyph
  function sendToWord(fromGlyph, type, data) {
    const i = fromGlyph.index;
    let lo = i, hi = i;
    while (lo > 0 && docText[lo - 1] !== ' ' && docText[lo - 1] !== '\n') lo--;
    while (hi < docText.length && docText[hi] !== ' ' && docText[hi] !== '\n') hi++;
    for (const g of glyphs) {
      if (g === fromGlyph || g.char === ' ' || g.char === '\n') continue;
      if (g.index >= lo && g.index < hi) {
        _outbox.push({ targetId: g.id, type, data: data || {}, fromId: fromGlyph.id });
      }
    }
  }

  // Queue to all non-space glyphs on the same line as fromGlyph
  function sendToLine(fromGlyph, type, data) {
    const lo = docText.lastIndexOf('\n', fromGlyph.index - 1) + 1;
    let hi = docText.indexOf('\n', fromGlyph.index);
    if (hi === -1) hi = docText.length;
    for (const g of glyphs) {
      if (g === fromGlyph || g.char === ' ' || g.char === '\n') continue;
      if (g.index >= lo && g.index < hi) {
        _outbox.push({ targetId: g.id, type, data: data || {}, fromId: fromGlyph.id });
      }
    }
  }

  // Schedule a message to targetId to fire delaySeconds from now
  function schedule(targetId, type, data, delaySeconds, bCtx) {
    const now = bCtx ? bCtx.time : performance.now() / 1000;
    _timers.push({ targetId, type, data: data || {}, fireAt: now + delaySeconds });
  }

  // Remove timers for glyph IDs that no longer exist in glyphs[]
  function pruneTimers() {
    const liveIds = new Set(glyphs.map(g => g.id));
    for (let i = _timers.length - 1; i >= 0; i--) {
      if (!liveIds.has(_timers[i].targetId)) _timers.splice(i, 1);
    }
  }

  // Main per-fixed-step entry point — 7 phases
  function processFrame(dt, bCtx) {
    const now = bCtx.time;

    // Phase 1 — Timer delivery: fire due timers → g.mailbox (immediate, this frame)
    for (let i = _timers.length - 1; i >= 0; i--) {
      const t = _timers[i];
      if (now >= t.fireAt) {
        const g = glyphs.find(h => h.id === t.targetId);
        if (g) g.mailbox.push({ type: t.type, data: t.data, fromId: null });
        _timers.splice(i, 1);
      }
    }

    // Phase 2 — System messages: 'tick', 'pointer-near', 'pointer-exit'
    //            Only dispatched to glyphs with a stateMachine.
    for (const g of glyphs) {
      if (!g.stateMachine) continue;
      g.mailbox.push({ type: 'tick', data: { dt }, fromId: null });
      if (bCtx.inputState.onCanvas) {
        const cx      = g.x + g.w * 0.5;
        const cy      = g.y - PARAMS.fontPt * 0.4;
        const d       = Math.hypot(bCtx.inputState.x - cx, bCtx.inputState.y - cy);
        const wasNear = g._state.get(_SYS_NEAR_SYM) || false;
        const isNear  = d <= NEAR_RADIUS;
        if (isNear  && !wasNear) g.mailbox.push({ type: 'pointer-near', data: { d }, fromId: null });
        if (!isNear && wasNear)  g.mailbox.push({ type: 'pointer-exit', data: { d }, fromId: null });
        g._state.set(_SYS_NEAR_SYM, isNear);
      }
    }

    // Phase 3 — Mailbox processing: drain each g.mailbox.
    //            Sends during processing go to _outbox (one-frame delivery delay).
    for (const g of glyphs) {
      if (g.mailbox.length === 0) continue;
      if (!g.stateMachine) { g.mailbox.length = 0; continue; }
      const msgs = g.mailbox.splice(0);
      for (const msg of msgs) {
        g.stateMachine.receive(g, msg, bCtx);
      }
    }

    // Phase 4 — Flush _outbox: deliver entries to target mailboxes.
    //            These will be processed in the NEXT frame's phase 3.
    if (_outbox.length > 0) {
      const byId = new Map(glyphs.map(g => [g.id, g]));
      for (const entry of _outbox) {
        const tg = byId.get(entry.targetId);
        if (tg) tg.mailbox.push({ type: entry.type, data: entry.data, fromId: entry.fromId });
      }
      _outbox.length = 0;
    }

    // Phase 5 — Tick behaviours (v1 unchanged)
    for (const g of glyphs) {
      for (const inst of g.behaviours) {
        inst.type.apply(g, dt, bCtx, inst.params);
      }
    }

    // Phase 6 — Dynamics integration + damping (v1 unchanged)
    for (const g of glyphs) {
      const d = g.dynamics;
      g.x        += d.vx         * dt;
      g.y        += d.vy         * dt;
      g.rotation += d.angularVel * dt;
      d.vx        *= d.damping;
      d.vy        *= d.damping;
      d.angularVel *= d.damping;
    }

    // Phase 7 — Particles (v1 unchanged)
    for (const g of glyphs) {
      if (g.geometry.type === 'particles' && g.geometry.data) {
        stepParticleGeometry(g, dt);
      }
    }
  }

  return { send, broadcast, sendToWord, sendToLine, schedule, processFrame, pruneTimers };
})();

// ── Contagion State Machine — demo ──────────────────────────────────────────────
// idle → receives 'excited' → excited
// excited → onEnter: broadcasts 'excited' (80px radius), schedules 'calm-down' (3s)
// excited → receives 'calm-down' → idle
// In excited: Shake + Flicker auto-activated by SM behaviour injection.
const contagionStates = {
  idle: {
    behaviours: [],
    onEnter(g, bCtx)  {},
    onExit(g, bCtx)   {},
    onMessage(g, msg, bCtx) {
      if (msg.type === 'excited') return 'excited';
    },
  },
  excited: {
    behaviours: [
      { type: Shake,   params: { amplitude: 8, speed: 20 } },
      { type: Flicker, params: { rate: 6, min: 0.1 } },
    ],
    onEnter(g, bCtx) {
      if (!bCtx) return;   // guard: null bCtx during pre-frame init
      bCtx.engine.broadcast(g, 80, 'excited', {});
      bCtx.engine.schedule(g.id, 'calm-down', {}, 3.0, bCtx);
    },
    onExit(g, bCtx)   {},
    onMessage(g, msg, bCtx) {
      if (msg.type === 'calm-down') return 'idle';
      // Ignore extra 'excited' while already excited
    },
  },
};

// Attach a fresh contagion SM to every printable glyph.
function attachContagion(gs) {
  for (const g of gs) {
    if (g.char === ' ' || g.char === '\n') continue;
    const sm = makeStateMachine(contagionStates, 'idle');
    sm.tag = 'contagion';
    g.stateMachine = sm;
    sm.init(g, null);
  }
}

// Detach contagion SM from every glyph (removes injected behaviours).
function detachContagion(gs) {
  for (const g of gs) {
    if (g.stateMachine?.tag === 'contagion') g.stateMachine.detach(g);
  }
}

// ── Predator / Prey State Machines ──────────────────────────────────────────────
// Predator: chases the pointer (Attract), broadcasts its position to nearby glyphs
//           as a 'hunt' message every tick while the pointer is on canvas.
// Prey:     on receiving 'hunt', flees from the predator's position (Flee behaviour);
//           calms down when not hunted for PRED_PREY_PARAMS.calmTime seconds.

// Tunable params — updated live by panel sliders.
const PRED_PREY_PARAMS = {
  huntRadius:      200,   // px — predator broadcast radius
  attractStrength: 280,   // predator Attract force strength
  fleeStrength:    400,   // prey Flee force strength
  fleeRadius:      350,   // px — prey Flee influence radius
  calmTime:        1.5,   // s — seconds without hunt before prey calms
};

const predatorStates = {
  idle: {
    behaviours: [],
    onEnter(g, bCtx)  {},
    onExit(g, bCtx)   {},
    onMessage(g, msg, bCtx) {
      if (msg.type === 'tick' && bCtx.inputState.onCanvas) return 'hunting';
    },
  },
  hunting: {
    // get behaviours() ensures each new injection reads current PRED_PREY_PARAMS
    get behaviours() {
      return [{ type: ChasePointer, params: { speed: PRED_PREY_PARAMS.attractStrength } }];
    },
    onEnter(g, bCtx)  {},
    onExit(g, bCtx)   {},
    onMessage(g, msg, bCtx) {
      if (msg.type === 'tick') {
        if (!bCtx.inputState.onCanvas) return 'idle';
        const px = g.x + g.w * 0.5, py = g.y - PARAMS.fontPt * 0.4;
        bCtx.engine.broadcast(g, PRED_PREY_PARAMS.huntRadius, 'hunt', { x: px, y: py });
      }
    },
  },
};

const preyStates = {
  idle: {
    behaviours: [],
    onEnter(g, bCtx)  {},
    onExit(g, bCtx)   {},
    onMessage(g, msg, bCtx) {
      if (msg.type === 'hunt') {
        g._state.set(Flee.sym, { tx: msg.data.x, ty: msg.data.y, lastHunt: bCtx.time });
        return 'fleeing';
      }
    },
  },
  fleeing: {
    get behaviours() {
      return [{ type: Flee, params: { strength: PRED_PREY_PARAMS.fleeStrength, radius: PRED_PREY_PARAMS.fleeRadius } }];
    },
    onEnter(g, bCtx) {
      if (!bCtx) return;
      bCtx.engine.schedule(g.id, 'calm', {}, 2.0, bCtx);
    },
    onExit(g, bCtx) {
      g._state.delete(Flee.sym);
    },
    onMessage(g, msg, bCtx) {
      if (msg.type === 'hunt') {
        const s = g._state.get(Flee.sym);
        if (s) { s.tx = msg.data.x; s.ty = msg.data.y; s.lastHunt = bCtx.time; }
      }
      if (msg.type === 'calm') {
        const s    = g._state.get(Flee.sym);
        const idle = !s || (bCtx.time - s.lastHunt) > PRED_PREY_PARAMS.calmTime;
        if (idle) return 'idle';
        bCtx.engine.schedule(g.id, 'calm', {}, 1.0, bCtx);
      }
    },
  },
};

// Attach predator/prey SMs. predGs become predators; the rest of printable allGs become prey.
// If predGs is empty, randomly assigns ~20% as predators.
function attachPredatorPrey(predGs, allGs) {
  const printable = allGs.filter(g => g.char !== ' ' && g.char !== '\n');
  let predSet = new Set(predGs.filter(g => g.char !== ' ' && g.char !== '\n'));
  if (predSet.size === 0) {
    // Random fallback: pick ~20%, at least 1
    const shuffled = [...printable].sort(() => Math.random() - 0.5);
    const n = Math.max(1, Math.floor(printable.length * 0.2));
    shuffled.slice(0, n).forEach(g => predSet.add(g));
  }
  for (const g of printable) {
    const isPred = predSet.has(g);
    const sm = makeStateMachine(isPred ? predatorStates : preyStates, 'idle');
    sm.tag = isPred ? 'predator' : 'prey';
    g.stateMachine = sm;
    sm.init(g, null);
  }
}

// Detach all predator/prey SMs and clean up.
function detachPredatorPrey(gs) {
  for (const g of gs) {
    if (g.stateMachine?.tag === 'predator' || g.stateMachine?.tag === 'prey') {
      g.stateMachine.detach(g);
    }
  }
}

// Push current PRED_PREY_PARAMS values into already-running behaviour instances.
// Call this whenever a param slider changes so live glyphs respond immediately.
function updatePredPreyBehaviourParams() {
  for (const g of glyphs) {
    if (g.stateMachine?.tag === 'predator') {
      for (const inst of g.behaviours) {
        if (inst.type === ChasePointer) inst.params.speed = PRED_PREY_PARAMS.attractStrength;
      }
    } else if (g.stateMachine?.tag === 'prey') {
      for (const inst of g.behaviours) {
        if (inst.type === Flee) {
          inst.params.strength = PRED_PREY_PARAMS.fleeStrength;
          inst.params.radius   = PRED_PREY_PARAMS.fleeRadius;
        }
      }
    }
  }
}

// ── Selection & behaviour authoring ─────────────────────────────────────────────
function nearestGlyph(mx, my) {
  let best = null, bestD = Infinity;
  for (const g of glyphs) {
    if (g.char === '\n' || g.char === ' ') continue;
    const d = Math.hypot(g.x + g.w * 0.5 - mx, g.y - PARAMS.fontPt * 0.4 - my);
    if (d < bestD) { bestD = d; best = g; }
  }
  return best;
}

function selectGlyphs(gs) {
  selectedGlyphs = gs;
  selectedIds    = new Set(gs.map(g => g.id));
  updateBehaviourPanel();
  updateGeometryPanel();
}

function selectWord(g) {
  const i = g.index;
  let lo = i, hi = i;
  while (lo > 0 && docText[lo - 1] !== ' ' && docText[lo - 1] !== '\n') lo--;
  while (hi < docText.length && docText[hi] !== ' ' && docText[hi] !== '\n') hi++;
  selectGlyphs(glyphs.filter(h => h.index >= lo && h.index < hi && h.char !== '\n' && h.char !== ' '));
}

function selectLine(g) {
  const lo = docText.lastIndexOf('\n', g.index - 1) + 1;
  let hi = docText.indexOf('\n', g.index);
  if (hi === -1) hi = docText.length;
  selectGlyphs(glyphs.filter(h => h.index >= lo && h.index < hi && h.char !== '\n' && h.char !== ' '));
}

const SENTENCE_END = new Set(['.', '!', '?']);

function selectSentenceOrLine(g) {
  const lo = docText.lastIndexOf('\n', g.index - 1) + 1;
  let hi = docText.indexOf('\n', g.index);
  if (hi === -1) hi = docText.length;

  // If the line contains no sentence-ending punctuation, select the whole line.
  let hasSentEnd = false;
  for (let i = lo; i < hi; i++) { if (SENTENCE_END.has(docText[i])) { hasSentEnd = true; break; } }
  if (!hasSentEnd) { selectLine(g); return; }

  // Sentence start: after previous sentence-ender within the line (skip leading spaces).
  let sentLo = g.index;
  while (sentLo > lo) {
    sentLo--;
    if (SENTENCE_END.has(docText[sentLo])) { sentLo++; break; }
  }
  while (sentLo < g.index && docText[sentLo] === ' ') sentLo++;

  // Sentence end: up to and including the next sentence-ender, or line end.
  let sentHi = g.index;
  while (sentHi < hi) {
    if (SENTENCE_END.has(docText[sentHi])) { sentHi++; break; }
    sentHi++;
  }

  selectGlyphs(glyphs.filter(h => h.index >= sentLo && h.index < sentHi && h.char !== '\n' && h.char !== ' '));
}

function setEditorMode(mode) {
  editorMode = mode;
  canvas.style.cursor = mode === 'type' ? 'text' : 'default';
  const sp = document.getElementById('selectionPanel');
  if (sp) sp.style.display = mode === 'select' ? 'block' : 'none';
  document.querySelectorAll('.mbtn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
  if (mode === 'type') {
    selectGlyphs([]);
  } else {
    anchorPos = cursorPos; // collapse any type-mode text selection
    // Pre-select the glyph adjacent to the cursor so the user can immediately
    // add behaviours after clicking near a letter in Type mode.
    if (selectedGlyphs.length === 0) {
      const g = glyphs.find(g => g.index === cursorPos - 1 && g.char !== '\n' && g.char !== ' ')
             || glyphs.find(g => g.index === cursorPos     && g.char !== '\n' && g.char !== ' ');
      if (g) selectGlyphs([g]);
    }
  }
}

function addBehaviour(defKey) {
  const def = BEHAVIOUR_DEFS.find(d => d.key === defKey);
  if (!def || selectedGlyphs.length === 0) return;
  pushUndo();
  const inst = { type: def.type, params: def.params.reduce((o, p) => ({ ...o, [p.key]: p.default }), {}) };
  for (const g of selectedGlyphs) g.behaviours.push(inst);
  updateBehaviourPanel();
}

function removeBehaviourAtIndex(idx) {
  pushUndo();
  for (const g of selectedGlyphs) g.behaviours.splice(idx, 1);
  updateBehaviourPanel();
}

function updateBehaviourPanel() {
  const panel = document.getElementById('bPanel');
  if (!panel) return;
  if (selectedGlyphs.length === 0) {
    panel.innerHTML = '<div class="bph-empty">No glyphs selected.<br>Click a glyph to select it.</div>';
    return;
  }
  const lbl  = selectedGlyphs.length === 1
    ? `"${selectedGlyphs[0].char}" selected`
    : `${selectedGlyphs.length} glyphs selected`;
  const behs = selectedGlyphs[0].behaviours;
  let html = `<div class="bph-sel-label">${lbl}</div>`;
  // SM state readout — updated live each frame via #smStateDisplay in the render loop
  if (selectedGlyphs[0].stateMachine) {
    const stateNow = selectedGlyphs[0].stateMachine.currentState();
    html = `<div style="font-size:10px;color:#666;margin-bottom:4px">state: <span id="smStateDisplay" style="color:#7af">${stateNow}</span></div>` + html;
  }
  for (let i = 0; i < behs.length; i++) {
    const inst = behs[i];
    const def  = BEHAVIOUR_DEFS.find(d => d.type === inst.type);
    if (!def) continue;
    html += `<div class="bph-behaviour">`;
    html += `<div class="bph-beh-header"><span class="bph-beh-label">${def.label}</span>`;
    html += `<button class="bph-beh-remove" data-idx="${i}">✕</button></div>`;
    for (const pd of def.params) {
      const v = inst.params[pd.key];
      html += `<div class="param-row" style="padding-left:10px">`;
      html += `<div class="param-header"><span class="param-name">${pd.label}</span>`;
      html += `<span class="param-val bph-pval" data-bidx="${i}" data-pk="${pd.key}">${v} ${pd.suffix}</span></div>`;
      html += `<input type="range" class="bph-slider" min="${pd.min}" max="${pd.max}" step="${pd.step}" value="${v}"`;
      html += ` data-bidx="${i}" data-pk="${pd.key}" data-sfx="${pd.suffix}">`;
      html += `</div>`;
    }
    html += `</div>`;
  }
  panel.innerHTML = html;
  panel.querySelectorAll('.bph-beh-remove').forEach(btn => {
    btn.addEventListener('click', () => removeBehaviourAtIndex(+btn.dataset.idx));
  });
  panel.querySelectorAll('.bph-slider').forEach(sl => {
    sl.addEventListener('input', () => {
      const bidx = +sl.dataset.bidx, pk = sl.dataset.pk, v = parseFloat(sl.value);
      for (const g of selectedGlyphs) { if (g.behaviours[bidx]) g.behaviours[bidx].params[pk] = v; }
      const valEl = panel.querySelector(`.bph-pval[data-bidx="${bidx}"][data-pk="${pk}"]`);
      if (valEl) valEl.textContent = `${v} ${sl.dataset.sfx}`;
    });
  });
}

// ── Particle geometry ───────────────────────────────────────────────────────────
// GeometryProvider for particle-based glyph rendering.
// Particle positions are in CSS px, local-space centred at (0, 0) = glyph visual centre.
// The provider is self-contained: build → step (each physics tick) → draw.

const DEFAULT_PARTICLE_PARAMS = {
  cellPx:        4,     // particle size in CSS px
  density:       156,   // percent of grid cells to fill (÷100 when used)
  particleSpeed: 100,   // px/s
  roundness:     62,    // particle shape: 0 = square, 100 = circle (÷100 when used)
  outside:       0,     // 0 = fully contained, 100 = freely wanders outside (÷100 when used)
  // perception/separation/alignment/cohesion live on the ParticleFlocking Behaviour
};

// Build (or rebuild) the particle data for a glyph.
// Safe to call multiple times; replaces g.geometry.data in-place.
function buildParticleGeometry(g) {
  if (g.char === '\n' || g.char === ' ') return;

  const pp      = g.geometry.params;
  const cell    = pp.cellPx;
  const density = pp.density / 100;
  const vmin    = pp.particleSpeed * 0.5;
  const vmax    = pp.particleSpeed * 1.5;

  // Build alpha mask on an offscreen canvas.
  // Glyph is rendered centred (textAlign='center', textBaseline='middle')
  // so local particle coords are centred at (0, 0).
  const pad  = 8;
  const fpx  = PARAMS.fontPt;   // CSS px — consistent with main canvas coordinate space
  let mW = Math.round(fpx * 1.25 + pad * 2);
  let mH = Math.round(fpx * 1.10 + pad * 2);
  if (mW % 2) mW++;
  if (mH % 2) mH++;

  const off  = document.createElement('canvas');
  off.width  = mW;
  off.height = mH;
  const octx = off.getContext('2d');
  octx.font         = fontStr();
  octx.textAlign    = 'center';
  octx.textBaseline = 'middle';
  octx.fillStyle    = '#fff';
  octx.fillText(g.char, mW / 2, mH / 2);

  const raw  = octx.getImageData(0, 0, mW, mH).data;
  const mask = new Uint8Array(mW * mH);
  for (let i = 0; i < mW * mH; i++) {
    mask[i] = raw[i * 4 + 3] > 128 ? 1 : 0;
  }

  // Collect all valid cell centres in local coords (glyph centred at origin).
  const allCells = [];
  const half = cell / 2;
  for (let ly = -mH / 2 + half; ly < mH / 2; ly += cell) {
    for (let lx = -mW / 2 + half; lx < mW / 2; lx += cell) {
      const xi = Math.round(lx + mW / 2);
      const yi = Math.round(ly + mH / 2);
      if (xi >= 0 && xi < mW && yi >= 0 && yi < mH && mask[yi * mW + xi]) {
        allCells.push({ x: lx, y: ly });
      }
    }
  }

  // Guard against invisible glyphs (e.g. unusual chars with no ink).
  if (allCells.length === 0) {
    g.geometry.data = { mask, maskW: mW, maskH: mH, allCells: [], particles: [] };
    return;
  }

  // Sample particle birth positions (Math.random for spawning, per flocking-07).
  const count = Math.max(1, Math.round(allCells.length * density));
  const cells = [];
  if (count >= allCells.length) {
    cells.push(...allCells);
    for (let i = allCells.length; i < count; i++) {
      cells.push(allCells[Math.floor(Math.random() * allCells.length)]);
    }
  } else {
    const idx = allCells.map((_, i) => i);
    for (let i = 0; i < count; i++) {
      const j = i + Math.floor(Math.random() * (idx.length - i));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    for (let i = 0; i < count; i++) cells.push(allCells[idx[i]]);
  }

  const particles = cells.map(({ x, y }) => {
    const spd   = vmin + Math.random() * (vmax - vmin);
    const angle = Math.random() * Math.PI * 2;
    return { x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, gx: x, gy: y };
  });

  g.geometry.data = { mask, maskW: mW, maskH: mH, allCells, particles };
}

// Advance the base particle simulation one physics step.
// Handles: crystallisation snap, wall avoidance, Outside return force, hard-bounce.
// Flocking is NOT run here — add the ParticleFlocking Behaviour to a glyph for that.
// This function is O(n) per glyph; ParticleFlocking is the O(n²) part.
function stepParticleGeometry(g, dt) {
  const pp = g.geometry.params;
  const gd = g.geometry.data;
  if (!gd || pp.cellPx <= 2) return;   // solid render mode — no stepping needed

  const ps        = gd.particles;
  const n         = ps.length;
  const cell      = pp.cellPx;
  const vmax      = pp.particleSpeed * 1.5;
  const vmin      = pp.particleSpeed * 0.5 * 0.3;
  const out       = pp.outside / 100;
  const wallD     = cell * 2.5;
  const solidifyT = Math.min(1, Math.max(0, 3 - pp.cellPx));

  const { mask, maskW, maskH } = gd;
  const inside = (lx, ly) => {
    const xi = Math.round(lx + maskW / 2);
    const yi = Math.round(ly + maskH / 2);
    if (xi < 0 || xi >= maskW || yi < 0 || yi >= maskH) return false;
    return mask[yi * maskW + xi] === 1;
  };

  for (let i = 0; i < n; i++) {
    const pi = ps[i];
    let fx = 0, fy = 0;

    // Crystallisation: snap toward birth grid position at small particle sizes.
    if (solidifyT > 0) {
      fx += (pi.gx - pi.x) * solidifyT * 20;
      fy += (pi.gy - pi.y) * solidifyT * 20;
    }

    // Wall avoidance: probe 8 directions; Outside weakens this so particles can drift out.
    const wallStr = 2.0 * (1 - out);
    if (wallStr > 0) {
      for (let k = 0; k < 8; k++) {
        const a  = k * Math.PI * 0.25;
        const wx = pi.x + Math.cos(a) * wallD;
        const wy = pi.y + Math.sin(a) * wallD;
        if (!inside(wx, wy)) {
          fx += (-Math.cos(a) * vmax - pi.vx) * wallStr;
          fy += (-Math.sin(a) * vmax - pi.vy) * wallStr;
        }
      }
    }

    pi.vx += fx * dt;
    pi.vy += fy * dt;

    // Speed clamping — limits scale toward zero as solidifyT rises so particles settle.
    const effMax = vmax * Math.max(0.02, 1 - solidifyT * 0.98);
    const effMin = vmin * (1 - solidifyT);
    const spd    = Math.hypot(pi.vx, pi.vy);
    if (spd > effMax) {
      pi.vx = pi.vx / spd * effMax;
      pi.vy = pi.vy / spd * effMax;
    } else if (effMin > 0 && spd < effMin && spd > 0) {
      pi.vx = pi.vx / spd * effMin;
      pi.vy = pi.vy / spd * effMin;
    } else if (spd === 0 && effMin > 0) {
      const a = g.rng() * Math.PI * 2;
      pi.vx = Math.cos(a) * effMin;
      pi.vy = Math.sin(a) * effMin;
    }

    // Move
    const nx = pi.x + pi.vx * dt;
    const ny = pi.y + pi.vy * dt;

    if (inside(nx, ny)) {
      pi.x = nx; pi.y = ny;
    } else if (!inside(pi.x, pi.y) || out > 0) {
      // Already outside, or Outside mode allows boundary crossing.
      // Return force aims at birth position (not glyph centre) to avoid
      // counter-cluster issues inside glyphs like 'o', 'h', 'e'.
      pi.x = nx; pi.y = ny;
      if (!inside(pi.x, pi.y)) {
        const ddx = pi.x - pi.gx, ddy = pi.y - pi.gy;
        const od  = Math.hypot(ddx, ddy);
        if (od > 0) {
          const rx    = ddx / od, ry = ddy / od;
          const blend = 1 - out * 0.85;   // at out=1: 15% return force always present
          const vOut  = pi.vx * rx + pi.vy * ry;
          if (vOut > 0) { pi.vx -= rx * vOut * blend; pi.vy -= ry * vOut * blend; }
          pi.vx -= rx * vmax * blend * 3.0 * dt;
          pi.vy -= ry * vmax * blend * 3.0 * dt;
        }
      }
    } else {
      // out=0 and particle is inside: hard-bounce to keep natural burbling.
      if      (inside(pi.x, ny)) { pi.y = ny; pi.vx = -pi.vx; }
      else if (inside(nx, pi.y)) { pi.x = nx; pi.vy = -pi.vy; }
      else                       { pi.vx = -pi.vx; pi.vy = -pi.vy; }
    }
  }
}

// Draw a glyph's particle cloud at its current world position.
// Uses ctx.save/restore so no canvas state leaks out.
function drawParticleGeometry(g) {
  const pp = g.geometry.params;
  const gd = g.geometry.data;
  if (!gd) return;

  // Visual centre of the glyph in CSS px (same anchor used for highlight rects).
  const wx = g.x + g.w / 2;
  const wy = g.y - PARAMS.fontPt * 0.4;

  ctx.save();
  ctx.translate(wx, wy);
  if (g.rotation !== 0) ctx.rotate(g.rotation);
  if (g.scale   !== 1) ctx.scale(g.scale, g.scale);

  const m = g.material;
  ctx.globalAlpha              = m.opacity;
  ctx.globalCompositeOperation = m.blendMode;
  ctx.fillStyle                = m.fill || PARAMS.color;

  if (pp.cellPx <= 2) {
    // Solid render at tiny sizes — avoids grey fringe and perf crawl.
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(g.char, 0, 0);
  } else {
    const cell  = pp.cellPx;
    const half  = cell / 2;
    const round = pp.roundness / 100;
    const r     = half * round;
    for (const p of gd.particles) {
      if (r <= 0) {
        ctx.fillRect(p.x - half, p.y - half, cell, cell);
      } else if (round >= 1) {
        ctx.beginPath(); ctx.arc(p.x, p.y, half, 0, Math.PI * 2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.roundRect(p.x - half, p.y - half, cell, cell, r); ctx.fill();
      }
    }
  }

  ctx.restore();
}

// Rebuild particle geometry for every glyph currently in particle mode.
// Call this after font family or font size changes — NOT on every keystroke.
function rebuildParticleGeometries() {
  for (const g of glyphs) {
    if (g.geometry.type === 'particles') buildParticleGeometry(g);
  }
}

// ── Geometry panel ──────────────────────────────────────────────────────────────
// Dynamic panel section for switching geometry type and tuning particle params.

const GEO_PARAM_DEFS = [
  { key: 'cellPx',        label: 'Particle Size',  min: 1,   max: 20,  step: 1,   suffix: 'px',   rebuild: true  },
  { key: 'density',       label: 'Density',        min: 10,  max: 300, step: 5,   suffix: '%',    rebuild: true  },
  { key: 'particleSpeed', label: 'Speed',          min: 10,  max: 400, step: 10,  suffix: 'px/s', rebuild: false },
  { key: 'roundness',     label: 'Shape',          min: 0,   max: 100, step: 1,   suffix: '%',    rebuild: false },
  { key: 'outside',       label: 'Outside',        min: 0,   max: 100, step: 1,   suffix: '%',    rebuild: false },
  // Flocking params removed — use the Particle Flocking behaviour instead.
];

function switchGeometryType(geoType) {
  if (selectedGlyphs.length === 0) return;
  for (const g of selectedGlyphs) {
    if (geoType === 'particles') {
      if (g.geometry.type !== 'particles') {
        g.geometry = { type: 'particles', params: { ...DEFAULT_PARTICLE_PARAMS }, data: null };
        buildParticleGeometry(g);
      }
    } else {
      g.geometry = { type: 'outline2d' };
    }
  }
  updateGeometryPanel();
}

function updateGeometryPanel() {
  const panel = document.getElementById('geoPanel');
  if (!panel) return;

  if (selectedGlyphs.length === 0) {
    panel.innerHTML = '';
    return;
  }

  const g0     = selectedGlyphs[0];
  const isPart = g0.geometry.type === 'particles';

  let html = `<div class="btn-group">`;
  html += `<button class="jbtn geo-type-btn ${!isPart ? 'active' : ''}" data-geo="outline2d">Outline</button>`;
  html += `<button class="jbtn geo-type-btn ${isPart  ? 'active' : ''}" data-geo="particles">Particles</button>`;
  html += `</div>`;

  if (isPart) {
    const pp = g0.geometry.params;
    for (const def of GEO_PARAM_DEFS) {
      if (def === null) {
        html += `<div class="geo-section-label">Flocking</div>`;
        continue;
      }
      const v    = pp[def.key];
      const disp = Number.isInteger(v) ? String(v) : v.toFixed(1);
      const sfxStr = def.suffix ? ' ' + def.suffix : '';
      html += `<div class="param-row">`;
      html += `<div class="param-header">`;
      html += `<span class="param-name">${def.label}</span>`;
      html += `<span class="param-val geo-pval" data-pk="${def.key}">${disp}${sfxStr}</span>`;
      html += `</div>`;
      html += `<input type="range" class="geo-slider" min="${def.min}" max="${def.max}" step="${def.step}" value="${v}"`;
      html += ` data-pk="${def.key}" data-sfx="${def.suffix}" data-rebuild="${def.rebuild}">`;
      html += `</div>`;
    }
    html += `<div class="param-row" style="margin-top:6px">`;
    html += `<button class="jbtn geo-rebuild-btn" style="width:100%">Rebuild Particles</button>`;
    html += `</div>`;
  }

  panel.innerHTML = html;

  panel.querySelectorAll('.geo-type-btn').forEach(btn => {
    btn.addEventListener('click', () => switchGeometryType(btn.dataset.geo));
  });

  if (isPart) {
    panel.querySelectorAll('.geo-slider').forEach(sl => {
      sl.addEventListener('input', () => {
        const pk          = sl.dataset.pk;
        const v           = parseFloat(sl.value);
        const needRebuild = sl.dataset.rebuild === 'true';
        for (const g of selectedGlyphs) {
          if (g.geometry.type !== 'particles') continue;
          g.geometry.params[pk] = v;
          if (needRebuild) buildParticleGeometry(g);
        }
        const sfx   = sl.dataset.sfx;
        const disp  = Number.isInteger(v) ? String(v) : v.toFixed(1);
        const sfxStr = sfx ? ' ' + sfx : '';
        const valEl = panel.querySelector(`.geo-pval[data-pk="${pk}"]`);
        if (valEl) valEl.textContent = `${disp}${sfxStr}`;
      });
    });

    panel.querySelector('.geo-rebuild-btn').addEventListener('click', () => {
      for (const g of selectedGlyphs) {
        if (g.geometry.type === 'particles') buildParticleGeometry(g);
      }
    });
  }
}

// ── Dynamics integration ────────────────────────────────────────────────────────
function stepDynamics(dt, bCtx) {
  for (const g of glyphs) {
    // Run all active behaviours before integrating position
    for (const inst of g.behaviours) {
      inst.type.apply(g, dt, bCtx, inst.params);
    }
    const d = g.dynamics;
    g.x        += d.vx         * dt;
    g.y        += d.vy         * dt;
    g.rotation += d.angularVel * dt;
    d.vx        *= d.damping;
    d.vy        *= d.damping;
    d.angularVel *= d.damping;

    // Internal particle physics (if particle geometry active)
    if (g.geometry.type === 'particles' && g.geometry.data) {
      stepParticleGeometry(g, dt);
    }
  }
}

// Returns the text-range selection as { lo, hi }, or null if no range active.
function selRange() {
  if (anchorPos === cursorPos) return null;
  return { lo: Math.min(anchorPos, cursorPos), hi: Math.max(anchorPos, cursorPos) };
}

// Returns the insertion-point index nearest to a mouse position.
function glyphPosFromMouse(mx, my) {
  if (glyphs.length === 0) return 0;
  let best = null, bestDist = Infinity;
  for (const g of glyphs) {
    if (g.char === '\n') continue;
    const d = Math.hypot(g.x + g.w * 0.5 - mx, g.y - PARAMS.fontPt * 0.4 - my);
    if (d < bestDist) { bestDist = d; best = g; }
  }
  return best ? best.index + 1 : docText.length;
}

// Returns true if (mx, my) is within the hit region of any selected glyph.
// Uses current visual position (g.x/y), not home, so works with drifted glyphs.
function overSelectedGlyphs(mx, my) {
  const pad = 10;
  const h   = PARAMS.fontPt;
  return selectedGlyphs.some(g => {
    if (g.char === '\n' || g.char === ' ') return false;
    return mx >= g.x - pad           && mx <= g.x + g.w + pad &&
           my >= g.y - h * 0.85 - pad && my <= g.y + h * 0.15 + pad;
  });
}

// ── Cursor helpers ─────────────────────────────────────────────────────────────
function cursorBaseline() {
  const lineH = PARAMS.fontPt * LINE_H_MULT;
  if (glyphs.length === 0) return { x: layoutOriginX, y: layoutOriginY ?? MARGIN + PARAMS.fontPt };

  // Use home positions so the cursor tracks typographic layout, not visual drift.
  // Prefer the glyph to the LEFT (cursor at its right edge — "insertion is after this char").
  const left = glyphs.find(g => g.index === cursorPos - 1);
  if (left) {
    if (left.char === '\n') {
      // Cursor is at the start of the next line.
      const first = glyphs.find(g => g.index >= cursorPos && g.char !== '\n');
      if (first) return { x: first.homeX, y: first.homeY };
      return { x: justifyX(0), y: left.homeY + lineH };
    }
    return { x: left.homeX + left.w, y: left.homeY };
  }

  const right = glyphs.find(g => g.index === cursorPos);
  if (right && right.char !== '\n') return { x: right.homeX, y: right.homeY };

  return { x: justifyX(0), y: MARGIN + PARAMS.fontPt };
}

// ── Cursor blink ───────────────────────────────────────────────────────────────
let cursorOn  = true;
let lastBlink = 0;
const BLINK_MS = 530;
function resetBlink() { cursorOn = true; lastBlink = performance.now(); }

// ── Render loop ────────────────────────────────────────────────────────────────
let lastTs      = null;
let accumulator = 0;

function loop(ts) {
  // Fixed-timestep physics
  const elapsed = lastTs !== null ? Math.min((ts - lastTs) / 1000, 0.1) : 0;
  lastTs = ts;
  accumulator += elapsed;
  const bCtx = { glyphs, inputState, time: ts / 1000, engine: AgentEngine };
  while (accumulator >= FIXED_DT) {
    AgentEngine.processFrame(FIXED_DT, bCtx);
    accumulator -= FIXED_DT;
  }

  // Cursor blink
  if (ts - lastBlink > BLINK_MS) { cursorOn = !cursorOn; lastBlink = ts; }

  // Clear
  ctx.fillStyle = PARAMS.background;
  ctx.fillRect(0, 0, W, H);

  // Draw glyphs
  ctx.font         = fontStr();
  ctx.textBaseline = 'alphabetic';

  // Cursor target highlight: only in type mode.
  const cursorTarget = (editorMode === 'type' && document.activeElement === canvas)
    ? (glyphs.find(g => g.index === cursorPos - 1 && g.char !== '\n' && g.char !== ' ') ||
       glyphs.find(g => g.index === cursorPos     && g.char !== '\n' && g.char !== ' '))
    : null;

  // Nearest glyph to mouse — recomputed every frame so it tracks drifting glyphs.
  let hoveredGlyph = null;
  if (inputState.onCanvas) {
    let hBest = null, hDist = Infinity;
    for (const g of glyphs) {
      if (g.char === '\n' || g.char === ' ') continue;
      const d = Math.hypot(g.x + g.w * 0.5 - inputState.x, g.y - PARAMS.fontPt * 0.4 - inputState.y);
      if (d < hDist) { hDist = d; hBest = g; }
    }
    hoveredGlyph = hBest;
  }

  // Text-range selection (Type mode only)
  const sr = editorMode === 'type' ? selRange() : null;

  for (const g of glyphs) {
    if (g.char === '\n' || g.char === ' ') continue;

    const m          = g.material;
    const isSelected = selectedIds.has(g.id);
    const isInRange  = sr !== null && g.index >= sr.lo && g.index < sr.hi;
    const isTarget   = g === cursorTarget;
    const isHovered  = g === hoveredGlyph && !isSelected;

    // ── Particle geometry path ──────────────────────────────────────────────
    if (g.geometry.type === 'particles') {
      // Highlight rect at glyph's current (possibly drifted) position.
      const r = [g.x - 2, g.y - PARAMS.fontPt * 0.85, g.w + 4, PARAMS.fontPt];
      ctx.globalCompositeOperation = 'source-over';
      if (isSelected) {
        ctx.fillStyle = '#fa7'; ctx.globalAlpha = 0.3; ctx.fillRect(...r);
        ctx.strokeStyle = '#fa7'; ctx.globalAlpha = 0.7; ctx.lineWidth = 1; ctx.strokeRect(...r);
      } else if (isInRange) {
        ctx.fillStyle = '#5ce'; ctx.globalAlpha = 0.4; ctx.fillRect(...r);
      } else if (isTarget) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
      } else if (isHovered) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
        ctx.strokeStyle = '#7af'; ctx.globalAlpha = 0.6; ctx.lineWidth = 1; ctx.strokeRect(...r);
      }
      ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
      drawParticleGeometry(g);
      continue;
    }

    // ── Outline2d geometry path ─────────────────────────────────────────────
    if (g.rotation !== 0 || g.scale !== 1) {
      const cx = g.x + g.w * 0.5;
      const cy = g.y - PARAMS.fontPt * 0.4;
      ctx.save();
      ctx.translate(cx, cy);
      if (g.rotation !== 0) ctx.rotate(g.rotation);
      if (g.scale   !== 1) ctx.scale(g.scale, g.scale);
      const r = [-g.w * 0.5 - 2, -PARAMS.fontPt * 0.85, g.w + 4, PARAMS.fontPt];
      ctx.globalCompositeOperation = 'source-over';
      if (isSelected) {
        ctx.fillStyle = '#fa7'; ctx.globalAlpha = 0.3; ctx.fillRect(...r);
        ctx.strokeStyle = '#fa7'; ctx.globalAlpha = 0.7; ctx.lineWidth = 1; ctx.strokeRect(...r);
      } else if (isInRange) {
        ctx.fillStyle = '#5ce'; ctx.globalAlpha = 0.4; ctx.fillRect(...r);
      } else if (isTarget) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
      } else if (isHovered) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
        ctx.strokeStyle = '#7af'; ctx.globalAlpha = 0.6; ctx.lineWidth = 1; ctx.strokeRect(...r);
      }
      ctx.globalAlpha              = m.opacity;
      ctx.globalCompositeOperation = m.blendMode;
      ctx.fillStyle                = m.fill || PARAMS.color;
      ctx.fillText(g.char, -g.w * 0.5, PARAMS.fontPt * 0.4);
      ctx.restore();
    } else {
      const r = [g.x - 2, g.y - PARAMS.fontPt * 0.85, g.w + 4, PARAMS.fontPt];
      ctx.globalCompositeOperation = 'source-over';
      if (isSelected) {
        ctx.fillStyle = '#fa7'; ctx.globalAlpha = 0.3; ctx.fillRect(...r);
        ctx.strokeStyle = '#fa7'; ctx.globalAlpha = 0.7; ctx.lineWidth = 1; ctx.strokeRect(...r);
      } else if (isInRange) {
        ctx.fillStyle = '#5ce'; ctx.globalAlpha = 0.4; ctx.fillRect(...r);
      } else if (isTarget) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
      } else if (isHovered) {
        ctx.fillStyle = '#7af'; ctx.globalAlpha = 0.25; ctx.fillRect(...r);
        ctx.strokeStyle = '#7af'; ctx.globalAlpha = 0.6; ctx.lineWidth = 1; ctx.strokeRect(...r);
      }
      ctx.globalAlpha              = m.opacity;
      ctx.globalCompositeOperation = m.blendMode;
      ctx.fillStyle                = m.fill || PARAMS.color;
      ctx.fillText(g.char, g.x, g.y);
    }
  }

  ctx.globalAlpha              = 1;
  ctx.globalCompositeOperation = 'source-over';

  // Cursor (type mode only)
  if (editorMode === 'type' && document.activeElement === canvas && cursorOn) {
    const bl = cursorBaseline();
    ctx.fillStyle = PARAMS.color;
    ctx.fillRect(bl.x, bl.y - PARAMS.fontPt * 0.85, 2, PARAMS.fontPt);
  }

  // Placeholder when empty and unfocused
  if (docText.length === 0 && document.activeElement !== canvas) {
    ctx.font         = `${Math.round(PARAMS.fontPt * 0.3)}px system-ui, sans-serif`;
    ctx.fillStyle    = '#333';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('click to start typing', MARGIN, MARGIN + PARAMS.fontPt * 0.3);
  }

  // Canvas boundary — drawn last so it's always visible over glyphs.
  ctx.globalAlpha              = 1;
  ctx.globalCompositeOperation = 'source-over';
  ctx.strokeStyle = 'rgba(180, 40, 40, 0.7)';
  ctx.lineWidth   = 1.5;
  ctx.strokeRect(0.75, 0.75, W - 1.5, H - 1.5);

  // Live SM state display — updated every frame when in select mode
  if (editorMode === 'select' && selectedGlyphs.length > 0) {
    const el = document.getElementById('smStateDisplay');
    if (el) {
      const sm = selectedGlyphs[0].stateMachine;
      el.textContent = sm ? sm.currentState() : '—';
    }
  }

  requestAnimationFrame(loop);
}

// ── Input: keyboard ────────────────────────────────────────────────────────────
// Listen on document so sidebar interactions (sliders, dropdowns, buttons) don't
// steal focus and break typing/deleting. Guard skips the handler when a panel
// form element is actively focused.
document.addEventListener('keydown', e => {
  const ae = document.activeElement;
  if (ae && ae !== canvas && ae.tagName !== 'BODY') return;

  const mod = e.ctrlKey || e.metaKey;

  if (mod && e.key === 'z') { if (e.shiftKey) redo(); else undo(); e.preventDefault(); return; }
  if (mod && e.key === 'y') { redo(); e.preventDefault(); return; }

  if (e.key === 'Escape') {
    if (editorMode === 'select') { selectGlyphs([]); e.preventDefault(); }
    return;
  }

  if (editorMode === 'select') {
    // Backspace / Delete removes the selected span from the document.
    if ((e.key === 'Backspace' || e.key === 'Delete') && selectedGlyphs.length > 0) {
      pushUndo();
      const indices = selectedGlyphs.map(g => g.index);
      const lo = Math.min(...indices);
      const hi = Math.max(...indices) + 1;
      docText = docText.slice(0, lo) + docText.slice(hi);
      cursorPos = anchorPos = lo;
      selectGlyphs([]);
      layout(); resetBlink(); e.preventDefault();
      if (docText.length === 0) setEditorMode('type');
    }
    return;
  }

  // Ctrl/Cmd+A: select all text
  if (mod && e.key === 'a') {
    anchorPos = 0; cursorPos = docText.length;
    resetBlink(); e.preventDefault(); return;
  }

  if (e.key === 'Backspace') {
    pushUndo();
    if (selectedGlyphs.length > 1) {
      // Multi-glyph selection (word / line / all): delete the selected span.
      const indices = selectedGlyphs.map(g => g.index);
      const lo = Math.min(...indices);
      const hi = Math.max(...indices) + 1;
      docText = docText.slice(0, lo) + docText.slice(hi);
      cursorPos = anchorPos = lo;
      selectGlyphs([]);
    } else {
      const sr = selRange();
      if (sr) {
        docText = docText.slice(0, sr.lo) + docText.slice(sr.hi);
        cursorPos = anchorPos = sr.lo;
      } else if (mod) {
        let i = cursorPos;
        while (i > 0 && (docText[i - 1] === ' ' || docText[i - 1] === '\n')) i--;
        while (i > 0 && docText[i - 1] !== ' ' && docText[i - 1] !== '\n') i--;
        docText = docText.slice(0, i) + docText.slice(cursorPos);
        cursorPos = anchorPos = i;
      } else if (cursorPos > 0) {
        docText = docText.slice(0, cursorPos - 1) + docText.slice(cursorPos);
        cursorPos--; anchorPos = cursorPos;
      }
    }
    layout(); resetBlink(); e.preventDefault();

  } else if (e.key === 'Delete') {
    pushUndo();
    if (selectedGlyphs.length > 1) {
      const indices = selectedGlyphs.map(g => g.index);
      const lo = Math.min(...indices);
      const hi = Math.max(...indices) + 1;
      docText = docText.slice(0, lo) + docText.slice(hi);
      cursorPos = anchorPos = lo;
      selectGlyphs([]);
    } else {
      const sr = selRange();
      if (sr) {
        docText = docText.slice(0, sr.lo) + docText.slice(sr.hi);
        cursorPos = anchorPos = sr.lo;
      } else if (cursorPos < docText.length) {
        docText = docText.slice(0, cursorPos) + docText.slice(cursorPos + 1);
      }
    }
    layout(); resetBlink(); e.preventDefault();

  } else if (e.key === 'Enter') {
    pushUndo();
    const sr = selRange();
    if (sr) {
      docText = docText.slice(0, sr.lo) + '\n' + docText.slice(sr.hi);
      cursorPos = anchorPos = sr.lo + 1;
    } else {
      docText = docText.slice(0, cursorPos) + '\n' + docText.slice(cursorPos);
      cursorPos++; anchorPos = cursorPos;
    }
    layout(); resetBlink(); e.preventDefault();

  } else if (e.key === 'ArrowLeft') {
    if (e.shiftKey) {
      // Extend selection leftward
      if (mod) {
        let i = cursorPos;
        while (i > 0 && (docText[i - 1] === ' ' || docText[i - 1] === '\n')) i--;
        while (i > 0 && docText[i - 1] !== ' ' && docText[i - 1] !== '\n') i--;
        cursorPos = i;
      } else {
        cursorPos = Math.max(0, cursorPos - 1);
      }
    } else if (selRange()) {
      cursorPos = anchorPos = Math.min(anchorPos, cursorPos); // collapse to left
    } else {
      if (mod) {
        let i = cursorPos;
        while (i > 0 && (docText[i - 1] === ' ' || docText[i - 1] === '\n')) i--;
        while (i > 0 && docText[i - 1] !== ' ' && docText[i - 1] !== '\n') i--;
        cursorPos = i;
      } else {
        cursorPos = Math.max(0, cursorPos - 1);
      }
      anchorPos = cursorPos;
    }
    resetBlink(); e.preventDefault();

  } else if (e.key === 'ArrowRight') {
    if (e.shiftKey) {
      // Extend selection rightward
      if (mod) {
        let i = cursorPos;
        while (i < docText.length && (docText[i] === ' ' || docText[i] === '\n')) i++;
        while (i < docText.length && docText[i] !== ' ' && docText[i] !== '\n') i++;
        cursorPos = i;
      } else {
        cursorPos = Math.min(docText.length, cursorPos + 1);
      }
    } else if (selRange()) {
      cursorPos = anchorPos = Math.max(anchorPos, cursorPos); // collapse to right
    } else {
      if (mod) {
        let i = cursorPos;
        while (i < docText.length && (docText[i] === ' ' || docText[i] === '\n')) i++;
        while (i < docText.length && docText[i] !== ' ' && docText[i] !== '\n') i++;
        cursorPos = i;
      } else {
        cursorPos = Math.min(docText.length, cursorPos + 1);
      }
      anchorPos = cursorPos;
    }
    resetBlink(); e.preventDefault();

  } else if (e.key === 'Home') {
    let i = cursorPos - 1;
    while (i >= 0 && docText[i] !== '\n') i--;
    cursorPos = i + 1;
    if (!e.shiftKey) anchorPos = cursorPos;
    resetBlink(); e.preventDefault();

  } else if (e.key === 'End') {
    let i = cursorPos;
    while (i < docText.length && docText[i] !== '\n') i++;
    cursorPos = i;
    if (!e.shiftKey) anchorPos = cursorPos;
    resetBlink(); e.preventDefault();

  } else if (e.key.length === 1 && !mod) {
    pushUndo();
    const sr = selRange();
    if (sr) {
      docText = docText.slice(0, sr.lo) + e.key + docText.slice(sr.hi);
      cursorPos = anchorPos = sr.lo + 1;
    } else {
      docText = docText.slice(0, cursorPos) + e.key + docText.slice(cursorPos);
      cursorPos++; anchorPos = cursorPos;
    }
    layout(); resetBlink(); e.preventDefault();
  }
});

// ── Input: paste ───────────────────────────────────────────────────────────────
canvas.addEventListener('paste', e => {
  const text = (e.clipboardData || window.clipboardData).getData('text/plain');
  if (!text) return;
  pushUndo();
  const sr = selRange();
  if (sr) {
    docText = docText.slice(0, sr.lo) + text + docText.slice(sr.hi);
    cursorPos = anchorPos = sr.lo + text.length;
  } else {
    docText = docText.slice(0, cursorPos) + text + docText.slice(cursorPos);
    cursorPos += text.length; anchorPos = cursorPos;
  }
  layout(); resetBlink();
  e.preventDefault();
});

// ── Input: click (multi-click scene-graph navigation) ──────────────────────────
// Works in both Type and Select modes:
//   1 click  = nearest glyph
//   2 clicks = word
//   3 clicks = sentence (if punctuation present) or whole line
//   4 clicks = all text
// Each click fires immediately and upgrades the previous selection.
// In Type mode a single click also moves the text cursor to after the clicked glyph.
let _clickCount  = 0;
let _clickAnchor = null;  // glyph from the first click in this sequence
let _clickTimer  = null;
const MULTI_CLICK_MS = 350;

// ── Drag state ─────────────────────────────────────────────────────────────────
let _dragActive  = false;
let _dragLastX   = 0;
let _dragLastY   = 0;
let _didDrag     = false;   // suppresses the click event that follows a drag
const DRAG_THRESHOLD = 4;   // px of movement before drag is committed

canvas.addEventListener('click', e => {
  canvas.focus();
  // Suppress click if a drag just finished.
  if (_didDrag) { _didDrag = false; return; }

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  clearTimeout(_clickTimer);
  _clickCount++;

  if (_clickCount === 1) {
    _clickAnchor = nearestGlyph(mx, my);
    // Treat as blank-canvas click if no glyph lands within its bounding box.
    if (_clickAnchor) {
      const h = PARAMS.fontPt, pad = Math.max(10, h * 0.2);
      const hit = mx >= _clickAnchor.x - pad && mx <= _clickAnchor.x + _clickAnchor.w + pad &&
                  my >= _clickAnchor.y - h * 0.85 - pad && my <= _clickAnchor.y + h * 0.15 + pad;
      if (!hit) _clickAnchor = null;
    }
    // Blank-canvas click in Type mode: move layout origin to click point.
    if (!_clickAnchor && editorMode === 'type') {
      layoutOriginX = Math.max(MARGIN * 0.5, Math.min(mx, W - MARGIN));
      layoutOriginY = Math.max(PARAMS.fontPt, Math.min(my, H - PARAMS.fontPt * 0.3));
      layout();
    }
    selectGlyphs(_clickAnchor ? [_clickAnchor] : []);
    // Also position the text cursor in Type mode.
    if (editorMode === 'type') {
      cursorPos = anchorPos = _clickAnchor ? _clickAnchor.index + 1 : docText.length;
    }
  } else if (_clickCount === 2) {
    if (_clickAnchor) selectWord(_clickAnchor);
  } else if (_clickCount === 3) {
    if (_clickAnchor) selectSentenceOrLine(_clickAnchor);
  } else {
    selectGlyphs(glyphs.filter(h => h.char !== '\n' && h.char !== ' '));
    _clickCount = 0;
    resetBlink();
    return;
  }

  _clickTimer = setTimeout(() => { _clickCount = 0; _clickAnchor = null; }, MULTI_CLICK_MS);
  resetBlink();
});

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  inputState.x = e.clientX - r.left;
  inputState.y = e.clientY - r.top;
  inputState.onCanvas = true;

  if (_dragActive && inputState.down) {
    const dx = inputState.x - _dragLastX;
    const dy = inputState.y - _dragLastY;
    if (!_didDrag && Math.hypot(dx, dy) < DRAG_THRESHOLD) return;
    if (!_didDrag) {
      _didDrag    = true;
      _clickCount = 0;        // reset multi-click so next click starts fresh
      clearTimeout(_clickTimer);
    }
    _dragLastX = inputState.x;
    _dragLastY = inputState.y;
    for (const g of selectedGlyphs) {
      g.x          += dx;
      g.y          += dy;
      g.dynamics.vx = 0;      // prevent accumulated forces from fighting the drag
      g.dynamics.vy = 0;
    }
  }

  // Cursor: 'grabbing' while dragging, 'grab' when hovering over selection.
  if (_dragActive && _didDrag) {
    canvas.style.cursor = 'grabbing';
  } else if (selectedGlyphs.length > 0 && overSelectedGlyphs(inputState.x, inputState.y)) {
    canvas.style.cursor = 'grab';
  } else {
    canvas.style.cursor = editorMode === 'type' ? 'text' : 'default';
  }
});
canvas.addEventListener('mouseleave', () => { inputState.onCanvas = false; });
canvas.addEventListener('mousedown', e => {
  inputState.down = true;
  canvas.focus();
  // Start a potential drag if the mouse is over the current selection.
  if (selectedGlyphs.length > 0) {
    const r  = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    if (overSelectedGlyphs(mx, my)) {
      pushUndo();
      _dragActive = true;
      _dragLastX  = mx;
      _dragLastY  = my;
      _didDrag    = false;
    }
  }
});
canvas.addEventListener('mouseup', () => {
  inputState.down = false;
  _dragActive = false;
  canvas.style.cursor = editorMode === 'type' ? 'text' : 'default';
});

// ── Panel wiring ───────────────────────────────────────────────────────────────
document.getElementById('sFontFamily').addEventListener('change', e => {
  PARAMS.fontFamily = e.target.value;
  layout();
  rebuildParticleGeometries();
});

document.getElementById('justifyGroup').addEventListener('click', e => {
  const btn = e.target.closest('.jbtn');
  if (!btn) return;
  PARAMS.justify = btn.dataset.val;
  document.querySelectorAll('#justifyGroup .jbtn').forEach(b => b.classList.toggle('active', b === btn));
  layout();
});

const sFontPt = document.getElementById('sFontPt');
const vFontPt = document.getElementById('vFontPt');
sFontPt.addEventListener('input', () => {
  PARAMS.fontPt = parseInt(sFontPt.value);
  vFontPt.textContent = PARAMS.fontPt + ' pt';
  layout();
  rebuildParticleGeometries();
});

document.getElementById('cText').addEventListener('input', e => { PARAMS.color      = e.target.value; });
document.getElementById('cBg'  ).addEventListener('input', e => { PARAMS.background = e.target.value; });

// ── Mode toggle ─────────────────────────────────────────────────────────────────
document.getElementById('modeGroup').addEventListener('click', e => {
  const btn = e.target.closest('.mbtn');
  if (!btn) return;
  setEditorMode(btn.dataset.mode);
});

// ── Add behaviour ───────────────────────────────────────────────────────────────
document.getElementById('bAdd').addEventListener('change', function() {
  if (!this.value) return;
  addBehaviour(this.value);
  this.value = '';
});

// ── Contagion toggle ─────────────────────────────────────────────────────────────
document.getElementById('contagionBtn').addEventListener('click', function() {
  const active = glyphs.some(g => g.stateMachine?.tag === 'contagion');
  if (active) {
    detachContagion(glyphs);
    this.textContent = 'Attach Contagion';
    this.classList.remove('active');
  } else {
    attachContagion(glyphs);
    this.textContent = 'Detach Contagion';
    this.classList.add('active');
  }
});

// ── Predator / Prey toggle ────────────────────────────────────────────────────────
document.getElementById('predPreyBtn').addEventListener('click', function() {
  const active = glyphs.some(g => g.stateMachine?.tag === 'predator' || g.stateMachine?.tag === 'prey');
  if (active) {
    detachPredatorPrey(glyphs);
    this.textContent = 'Attach Pred/Prey';
    this.classList.remove('active');
    document.getElementById('predPreyParams').style.display = 'none';
  } else {
    attachPredatorPrey(selectedGlyphs, glyphs);
    this.textContent = 'Detach Pred/Prey';
    this.classList.add('active');
    document.getElementById('predPreyParams').style.display = '';
  }
});

// ── Predator / Prey parameter sliders ────────────────────────────────────────────
(function() {
  function wire(sliderId, valId, key, suffix, decimals) {
    const sl = document.getElementById(sliderId);
    const vl = document.getElementById(valId);
    sl.addEventListener('input', () => {
      const v = parseFloat(sl.value);
      PRED_PREY_PARAMS[key] = v;
      vl.textContent = decimals ? v.toFixed(decimals) + (suffix || '') : v + (suffix || '');
      updatePredPreyBehaviourParams();
    });
  }
  wire('sHuntRadius',      'vHuntRadius',      'huntRadius',      ' px', 0);
  wire('sAttractStrength', 'vAttractStrength', 'attractStrength', '',    0);
  wire('sFleeStrength',    'vFleeStrength',    'fleeStrength',    '',    0);
  wire('sCalmTime',        'vCalmTime',        'calmTime',        ' s',  1);
})();

// ── Send agent message ───────────────────────────────────────────────────────────
document.getElementById('smSendBtn').addEventListener('click', () => {
  const inp  = document.getElementById('smTriggerInput');
  const type = inp.value.trim();
  if (!type || selectedGlyphs.length === 0) return;
  for (const g of selectedGlyphs) AgentEngine.send(g, type, {}, 'user');
});

// ── Init ───────────────────────────────────────────────────────────────────────
resizeCanvas();
requestAnimationFrame(loop);
canvas.focus();
</script>
</body>
</html>
